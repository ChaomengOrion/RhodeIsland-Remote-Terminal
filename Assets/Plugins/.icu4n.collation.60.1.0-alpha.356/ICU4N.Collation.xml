<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ICU4N.Collation</name>
    </assembly>
    <members>
        <member name="T:ICU4N.Impl.Coll.BOCSU">
            <summary>
            Binary Ordered Compression Scheme for Unicode
            <para/>
            Users are strongly encouraged to read the ICU paper on
            <a href="http://www.icu-project.org/docs/papers/binary_ordered_compression_for_unicode.html">
            BOCU</a> before attempting to use this class.
            </summary>
            <remarks>
            BOCU is used to compress unicode text into a stream of unsigned
            bytes.  For many kinds of text the compression compares favorably
            to UTF-8, and for some kinds of text (such as CJK) it does better.
            The resulting bytes will compare in the same order as the original
            code points.  The byte stream does not contain the values 0, 1, or
            2.
            <para/>
            One example of a use of BOCU is in <see cref="M:ICU4N.Text.Collator.GetCollationKey(System.String)"/>
            for a <see cref="T:ICU4N.Text.RuleBasedCollator"/> object with collation strength
            <see cref="F:ICU4N.Text.CollationStrength.Identical"/>. The result <see cref="T:ICU4N.Text.CollationKey"/> 
            will consist of the collation order of the source string followed by the BOCU result of the 
            source string.
            <para/>
            Unlike a UTF encoding, BOCU-compressed text is not suitable for
            random access.
            <para/>
            Method: Slope Detection<br/> Remember the previous code point
            (initial 0).  For each code point in the string, encode the
            difference with the previous one.  Similar to a UTF, the length of
            the byte sequence is encoded in the lead bytes.  Unlike a UTF, the
            trail byte values may overlap with lead/single byte values.  The
            trail byte values may overlap with lead/single byte values.  The
            significant part.
            <para/>
            We encode differences with few bytes if their absolute values
            are small.  For correct ordering, we must treat the entire value
            range -10ffff..+10ffff in ascending order, which forbids encoding
            the sign and the absolute value separately. Instead, we split the
            lead byte range in the middle and encode non-negative values going
            up and negative values going down.
            <para/>
            For very small absolute values, the difference is added to a
            middle byte value for single-byte encoded differences.  For
            somewhat larger absolute values, the difference is divided by the
            number of byte values available, the modulo is used for one trail
            byte, and the remainder is added to a lead byte avoiding the
            single-byte range.  For large absolute values, the difference is
            similarly encoded in three bytes. (Syn Wee, I need examples
            here.)
            <para/>
            BOCU does not use byte values 0, 1, or 2, but uses all other
            byte values for lead and single bytes, so that the middle range of
            single bytes is as large as possible.
            <para/>
            Note that the lead byte ranges overlap some, but that the
            sequences as a whole are well ordered. I.e., even if the lead byte
            is the same for sequences of different lengths, the trail bytes
            establish correct order.  It would be possible to encode slightly
            larger ranges for each length (>1) by subtracting the lower bound
            of the range. However, that would also slow down the calculation.
            (Syn Wee, need an example).
            <para/>
            For the actual string encoding, an optimization moves the
            previous code point value to the middle of its Unicode script block
            to minimize the differences in same-script text runs.  (Syn Wee,
            need an example.)
            </remarks>
            <author>Syn Wee Quek</author>
            <since>release 2.2, May 3rd 2002</since>
        </member>
        <member name="M:ICU4N.Impl.Coll.BOCSU.WriteIdenticalLevelRun(System.Int32,J2N.Text.ICharSequence,System.Int32,System.Int32,ICU4N.Util.ByteArrayWrapper)">
            <summary>
            Encode the code points of a string as
            a sequence of byte-encoded differences (slope detection),
            preserving lexical order.
            </summary>
            <remarks>
            Optimize the difference-taking for runs of Unicode text within
            small scripts:
            <para/>
            Most small scripts are allocated within aligned 128-blocks of Unicode
            code points. Lexical order is preserved if "prev" is always moved
            into the middle of such a block.
            <para/>
            Additionally, "prev" is moved from anywhere in the Unihan
            area into the middle of that area.
            Note that the identical-level run in a sort key is generated from
            NFD text - there are never Hangul characters included.
            </remarks>
        </member>
        <member name="F:ICU4N.Impl.Coll.BOCSU.SLOPE_MIN_">
            <summary>
            Do not use byte values 0, 1, 2 because they are separators in sort keys.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.BOCSU.SLOPE_SINGLE_">
            <summary>
            Number of lead bytes:
            1        middle byte for 0
            2*80=160 single bytes for !=0
            2*42=84  for double-byte values
            2*3=6    for 3-byte values
            2*1=2    for 4-byte values
            <para/>
            The sum must be &lt;=SLOPE_TAIL_COUNT.
            <para/>
            Why these numbers?
            - There should be >=128 single-byte values to cover 128-blocks
              with small scripts.
            - There should be >=20902 single/double-byte values to cover Unihan.
            - It helps CJK Extension B some if there are 3-byte values that cover
              the distance between them and Unihan.
              This also helps to jump among distant places in the BMP.
            - Four-byte values are necessary to cover the rest of Unicode.
            <para/>
            Symmetrical lead byte counts are for convenience.
            With an equal distribution of even and odd differences there is also
            no advantage to asymmetrical lead byte counts.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.BOCSU.SLOPE_REACH_POS_1_">
            <summary>
            The difference value range for single-byters.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.BOCSU.SLOPE_REACH_POS_2_">
            <summary>
            The difference value range for double-byters.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.BOCSU.SLOPE_REACH_POS_3_">
            <summary>
            The difference value range for 3-byters.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.BOCSU.SLOPE_START_POS_2_">
            <summary>
            The lead byte start values.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.BOCSU.GetNegDivMod(System.Int32,System.Int32)">
            <summary>
            Integer division and modulo with negative numerators
            yields negative modulo results and quotients that are one more than
            what we need here.
            </summary>
            <param name="number">Which operations are to be performed on.</param>
            <param name="factor">The factor to use for division.</param>
            <returns>(result of division) &lt;&lt; 32 | modulo</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.BOCSU.WriteDiff(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encode one difference value -0x10ffff..+0x10ffff in 1..4 bytes,
            preserving lexical order.
            </summary>
            <param name="diff"></param>
            <param name="buffer">Byte buffer to append to.</param>
            <param name="offset">Offset to the byte buffer to start appending.</param>
            <returns>End offset where the appending stops.</returns>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationSortKeyLevel">
            <summary>
            Sort key levels.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSortKeyLevel.Unspecified">
            <summary>Unspecified level.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSortKeyLevel.Zero">
            <summary>Beyond sort key bytes.</summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.Collation">
            <summary>
            Collation v2 basic definitions and static helper functions.
            <para/>
            Data structures except for expansion tables store 32-bit CEs which are
            either specials (see tags below) or are compact forms of 64-bit CEs.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.SentinelCodePoint">
            <summary>
            UChar32 U_SENTINEL.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.BEFORE_WEIGHT16">
            <summary>The secondary/tertiary lower limit for tailoring before any root elements.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.MergeSeparatorByte">
            <summary>
            Merge-sort-key separator.
            Same as the unique primary and identical-level weights of U+FFFE.
            Must not be used as primary compression low terminator.
            Otherwise usable.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.PrimaryCompressionLowByte">
            <summary>
            Primary compression low terminator, must be greater than <see cref="F:ICU4N.Impl.Coll.Collation.MergeSeparatorByte"/>.
            Reserved value in primary second byte if the lead byte is compressible.
            Otherwise usable in all CE weight bytes.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.PrimaryCompressionHighByte">
            <summary>
            Primary compression high terminator.
            Reserved value in primary second byte if the lead byte is compressible.
            Otherwise usable in all CE weight bytes.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.COMMON_BYTE">
            <summary>Default secondary/tertiary weight lead byte.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.COMMON_SECONDARY_CE">
            <summary>Middle 16 bits of a CE with a common secondary weight.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.COMMON_TERTIARY_CE">
            <summary>Lower 16 bits of a CE with a common tertiary weight.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.CommonSecondaryAndTertiaryCE">
            <summary>Lower 32 bits of a CE with common secondary and tertiary weights.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.OnlyTertiaryMask">
            <summary>Only the 2*6 bits for the pure tertiary weight.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.ONLY_SEC_TER_MASK">
            <summary>Only the secondary &amp; tertiary bits; no case, no quaternary.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.CASE_AND_TERTIARY_MASK">
            <summary>Case bits and tertiary bits.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.CaseAndQuaternaryMask">
            <summary>Case bits and quaternary bits.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.FIRST_UNASSIGNED_PRIMARY">
            <summary>
            First unassigned: AlphabeticIndex overflow boundary.
            We want a 3-byte primary so that it fits into the root elements table.
            <para/>
            This 3-byte primary will not collide with
            any unassigned-implicit 4-byte primaries because
            the first few hundred Unicode code points all have real mappings.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.SPECIAL_CE32_LOW_BYTE">
            <summary>
            A CE32 is special if its low byte is this or greater.
            Impossible case bits 11 mark special CE32s.
            This value itself is used to indicate a fallback to the base collator.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.LONG_PRIMARY_CE32_LOW_BYTE">
            <summary>
            Low byte of a long-primary special CE32.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.NO_CE_PRIMARY">
            <summary>No CE: End of input. Only used in runtime code, not stored in data.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.NO_LEVEL_FLAG">
            <summary>
            Sort key level flags: xx_FLAG = 1 &lt;&lt; xx_LEVEL.
            In Java, use enum Level with flag() getters, or use EnumSet rather than hand-made bit sets.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.FALLBACK_TAG">
            Special-CE32 tags, from bits 3..0 of a special 32-bit CE.
            Bits 31..8 are available for tag-specific data.
            Bits  5..4: Reserved. May be used in the future to indicate lccc!=0 and tccc!=0.
            <summary>
            Fall back to the base collator.
            This is the tag value in <see cref="F:ICU4N.Impl.Coll.Collation.SPECIAL_CE32_LOW_BYTE"/> and <see cref="F:ICU4N.Impl.Coll.Collation.FALLBACK_CE32"/>.
            Bits 31..8: Unused, 0.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.LONG_PRIMARY_TAG">
            <summary>
            Long-primary CE with <see cref="F:ICU4N.Impl.Coll.Collation.CommonSecondaryAndTertiaryCE"/>.
            Bits 31..8: Three-byte primary.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.LONG_SECONDARY_TAG">
            <summary>
            Long-secondary CE with zero primary.
            Bits 31..16: Secondary weight.
            Bits 15.. 8: Tertiary weight.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.RESERVED_TAG_3">
            <summary>
            Unused.
            May be used in the future for single-byte secondary CEs (SHORT_SECONDARY_TAG),
            storing the secondary in bits 31..24, the ccc in bits 23..16,
            and the tertiary in bits 15..8.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.LATIN_EXPANSION_TAG">
            <summary>
            Latin mini expansions of two simple CEs [pp, 05, tt] [00, ss, 05].
            Bits 31..24: Single-byte primary weight pp of the first CE.
            Bits 23..16: Tertiary weight tt of the first CE.
            Bits 15.. 8: Secondary weight ss of the second CE.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.EXPANSION32_TAG">
            <summary>
            Points to one or more simple/long-primary/long-secondary 32-bit CE32s.
            Bits 31..13: Index into int table.
            Bits 12.. 8: Length=1..31.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.EXPANSION_TAG">
            <summary>
            Points to one or more 64-bit CEs.
            Bits 31..13: Index into CE table.
            Bits 12.. 8: Length=1..31.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.BUILDER_DATA_TAG">
            <summary>
            Builder data, used only in the CollationDataBuilder, not in runtime data.
            <para/>
            If bit 8 is 0: Builder context, points to a list of context-sensitive mappings.
            Bits 31..13: Index to the builder's list of ConditionalCE32 for this character.
            Bits 12.. 9: Unused, 0.
            <para/>
            If bit 8 is 1 (IS_BUILDER_JAMO_CE32): Builder-only jamoCE32 value.
            The builder fetches the Jamo CE32 from the trie.
            Bits 31..13: Jamo code point.
            Bits 12.. 9: Unused, 0.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.PREFIX_TAG">
            <summary>
            Points to prefix trie.
            Bits 31..13: Index into prefix/contraction data.
            Bits 12.. 8: Unused, 0.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.CONTRACTION_TAG">
            <summary>
            Points to contraction data.
            Bits 31..13: Index into prefix/contraction data.
            Bits 12..11: Unused, 0.
            Bit      10: CONTRACT_TRAILING_CCC flag.
            Bit       9: CONTRACT_NEXT_CCC flag.
            Bit       8: CONTRACT_SINGLE_CP_NO_MATCH flag.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.DIGIT_TAG">
            <summary>
            Decimal digit.
            Bits 31..13: Index into int table for non-numeric-collation CE32.
            Bit      12: Unused, 0.
            Bits 11.. 8: Digit value 0..9.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.U0000_TAG">
            <summary>
            Tag for U+0000, for moving the NUL-termination handling
            from the regular fastpath into specials-handling code.
            Bits 31..8: Unused, 0.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.HANGUL_TAG">
            <summary>
            Tag for a Hangul syllable.
            Bits 31..9: Unused, 0.
            Bit      8: HANGUL_NO_SPECIAL_JAMO flag.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.LEAD_SURROGATE_TAG">
            <summary>
            Tag for a lead surrogate code unit.
            Optional optimization for UTF-16 string processing.
            Bits 31..10: Unused, 0.
                  9.. 8: =0: All associated supplementary code points are unassigned-implict.
                         =1: All associated supplementary code points fall back to the base data.
                         else: (Normally 2) Look up the data for the supplementary code point.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.OFFSET_TAG">
            <summary>
            Tag for CEs with primary weights in code point order.
            Bits 31..13: Index into CE table, for one data "CE".
            Bits 12.. 8: Unused, 0.
            <para/>
            This data "CE" has the following bit fields:
            Bits 63..32: Three-byte primary pppppp00.
                 31.. 8: Start/base code point of the in-order range.
                      7: Flag isCompressible primary.
                  6.. 0: Per-code point primary-weight increment.          
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.IMPLICIT_TAG">
            <summary>
            Implicit CE tag. Compute an unassigned-implicit CE.
            All bits are set (UNASSIGNED_CE32=0xffffffff).
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.MAX_EXPANSION_LENGTH">
            <summary>
            We limit the number of CEs in an expansion
            so that we can use a small number of length bits in the data structure,
            and so that an implementation can copy CEs at runtime without growing a destination buffer.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.CONTRACT_SINGLE_CP_NO_MATCH">
            <summary>
            Set if there is no match for the single (no-suffix) character itself.
            This is only possible if there is a prefix.
            In this case, discontiguous contraction matching cannot add combining marks
            starting from an empty suffix.
            The default CE32 is used anyway if there is no suffix match.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.CONTRACT_NEXT_CCC">
            <summary>Set if the first character of every contraction suffix has lccc!=0.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.CONTRACT_TRAILING_CCC">
            <summary>Set if any contraction suffix ends with lccc!=0.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.HANGUL_NO_SPECIAL_JAMO">
            <summary>For HANGUL_TAG: None of its Jamo CE32s <see cref="M:ICU4N.Impl.Coll.Collation.IsSpecialCE32(System.Int32)"/>.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.PrimaryFromLongPrimaryCE32(System.Int32)">
            <summary>Turns the long-primary CE32 into a primary weight pppppp00.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.MakeCE32FromTagIndexAndLength(System.Int32,System.Int32,System.Int32)">
            <summary>Makes a special CE32 with <paramref name="tag"/>, <paramref name="index"/> and <paramref name="length"/>.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.MakeCE32FromTagAndIndex(System.Int32,System.Int32)">
            <summary>Makes a special CE32 with only <paramref name="tag"/> and <paramref name="index"/>.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.IsSelfContainedCE32(System.Int32)">
            <returns>true if the ce32 yields one or more CEs without further data lookups.</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.LatinCE0FromCE32(System.Int32)">
            <summary>
            Get the first of the two Latin-expansion CEs encoded in ce32.
            </summary>
            <seealso cref="F:ICU4N.Impl.Coll.Collation.LATIN_EXPANSION_TAG"/>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.LatinCE1FromCE32(System.Int32)">
            <summary>
            Get the second of the two Latin-expansion CEs encoded in ce32.
            </summary>
            <seealso cref="F:ICU4N.Impl.Coll.Collation.LATIN_EXPANSION_TAG"/>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.IndexFromCE32(System.Int32)">
            <summary>
            Returns the data index from a special CE32.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.LengthFromCE32(System.Int32)">
            <summary>
            Returns the data length from a ce32.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.DigitFromCE32(System.Int32)">
            <summary>
            Returns the digit value from a <see cref="F:ICU4N.Impl.Coll.Collation.DIGIT_TAG"/> ce32.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.CeFromSimpleCE32(System.Int32)">
            <summary>Returns a 64-bit CE from a simple CE32 (not special).</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.CeFromCE32(System.Int32)">
            <summary>Returns a 64-bit CE from a simple/long-primary/long-secondary CE32.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.MakeCE(System.Int64)">
            <summary>Creates a CE from a primary weight.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.MakeCE(System.Int64,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a CE from a primary weight,
            16-bit secondary/tertiary weights, and a 2-bit quaternary.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.IncTwoBytePrimaryByOffset(System.Int64,System.Boolean,System.Int32)">
            <summary>
            Increments a 2-byte primary by a code point offset.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.IncThreeBytePrimaryByOffset(System.Int64,System.Boolean,System.Int32)">
            <summary>
            Increments a 3-byte primary by a code point offset.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.DecTwoBytePrimaryByOneStep(System.Int64,System.Boolean,System.Int32)">
            <summary>
            Decrements a 2-byte primary by one range step (1..0x7f).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.DecThreeBytePrimaryByOneStep(System.Int64,System.Boolean,System.Int32)">
            <summary>
            Decrements a 3-byte primary by one range step (1..0x7f).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.GetThreeBytePrimaryForOffsetData(System.Int32,System.Int64)">
            <summary>
            Computes a 3-byte primary for c's OFFSET_TAG data "CE".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.UnassignedPrimaryFromCodePoint(System.Int32)">
            <summary>
            Returns the unassigned-character implicit primary weight for any valid code point c.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.ICU4N#Impl#Coll#CollationRuleParser#ISink#AddReset(ICU4N.Text.CollationStrength,J2N.Text.ICharSequence)">
            <summary>Implements <see cref="T:ICU4N.Impl.Coll.CollationRuleParser.ISink"/>.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.GetWeight16Before(System.Int32,System.Int64,ICU4N.Text.CollationStrength)">
            <summary>
            Returns the secondary or tertiary weight preceding the current node's weight.
            node=nodes[index].
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.ICU4N#Impl#Coll#CollationRuleParser#ISink#AddRelation(ICU4N.Text.CollationStrength,J2N.Text.ICharSequence,J2N.Text.ICharSequence,System.String)">
            <summary>Implements <see cref="T:ICU4N.Impl.Coll.CollationRuleParser.ISink"/>.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.FindOrInsertNodeForCEs(ICU4N.Text.CollationStrength)">
            <summary>
            Picks one of the current CEs and finds or inserts a node in the graph
            for the CE + strength.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.BinarySearchForRootPrimaryNode(System.Collections.Generic.IList{System.Int32},System.Int32,System.Collections.Generic.IList{System.Int64},System.Int64)">
            <summary>
            Like Java Collections.binarySearch(List, key, Comparator).
            </summary>
            <returns>The index>=0 where the item was found,
            or the index&lt;0 for inserting the string at ~index in sorted order
            (index into rootPrimaryIndexes)</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.FindOrInsertNodeForPrimary(System.Int64)">
            <summary>Finds or inserts the node for a root CE's primary weight.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.FindOrInsertWeakNode(System.Int32,System.Int32,ICU4N.Text.CollationStrength)">
            <summary>Finds or inserts the node for a secondary or tertiary weight.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.InsertTailoredNodeAfter(System.Int32,ICU4N.Text.CollationStrength)">
            <summary>
            Makes and inserts a new tailored node into the list, after the one at <paramref name="index"/>.
            Skips over nodes of weaker strength to maintain collation order
            ("postpone insertion").
            </summary>
            <returns>The new node's index.</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.InsertNodeBetween(System.Int32,System.Int32,System.Int64)">
            <summary>
            Inserts a new node into the list, between list-adjacent items.
            The node's previous and next indexes must not be set yet.
            </summary>
            <returns>The new node's index.</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.FindCommonNode(System.Int32,ICU4N.Text.CollationStrength)">
            <summary>
            Finds the node which implies or contains a common=05 weight of the given <paramref name="strength"/>
            (secondary or tertiary), if the current node is stronger.
            Skips weaker nodes and tailored nodes if the current node is stronger
            and is followed by an explicit-common-weight node.
            Always returns the input <paramref name="index"/> if that node is no stronger than the given <paramref name="strength"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.ICU4N#Impl#Coll#CollationRuleParser#ISink#SuppressContractions(ICU4N.Text.UnicodeSet)">
            <summary>Implements <see cref="T:ICU4N.Impl.Coll.CollationRuleParser.ISink"/>.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.ICU4N#Impl#Coll#CollationRuleParser#ISink#Optimize(ICU4N.Text.UnicodeSet)">
            <summary>Implements <see cref="T:ICU4N.Impl.Coll.CollationRuleParser.ISink"/>.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.AddWithClosure(J2N.Text.ICharSequence,J2N.Text.ICharSequence,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Adds the mapping and its canonical closure.
            Takes ce32=dataBuilder.EncodeCEs(...) so that the data builder
            need not re-encode the CEs multiple times.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.MakeTailoredCEs">
            <summary>
            Walks the tailoring graph and overwrites tailored nodes with new CEs.
            After this, the graph is destroyed.
            The nodes array can then be used only as a source of tailored CEs.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.CountTailoredNodes(System.Collections.Generic.IList{System.Int64},System.Int32,ICU4N.Text.CollationStrength)">
            <summary>
            Counts the tailored nodes of the given strength up to the next node
            which is either stronger or has an explicit weight of this <paramref name="strength"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.FinalizeCEs">
            <summary>Replaces temporary CEs with the final CEs they point to.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.TempCEFromIndexAndStrength(System.Int32,ICU4N.Text.CollationStrength)">
            <summary>
            Encodes "temporary CE" data into a CE that fits into the CE32 data structure,
            with 2-byte primary, 1-byte secondary and 6-bit tertiary,
            with valid CE byte values.
            <para/>
            The index must not exceed 20 bits (0xfffff).
            The strength must fit into 2 bits (<see cref="F:ICU4N.Text.CollationStrength.Primary"/>..<see cref="F:ICU4N.Text.CollationStrength.Quaternary"/>).
            <para/>
            Temporary CEs are distinguished from real CEs by their use of
            secondary weights 06..45 which are otherwise reserved for compressed sort keys.
            <para/>
            The case bits are unused and available.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationBuilder.MAX_INDEX">
            <summary>At most 1M nodes, limited by the 20 bits in node bit fields.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationBuilder.HAS_BEFORE2">
            <summary>
            Node bit 6 is set on a primary node if there are nodes
            with secondary values below the common secondary weight (05).
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationBuilder.HAS_BEFORE3">
            <summary>
            Node bit 5 is set on a primary or secondary node if there are nodes
            with tertiary values below the common tertiary weight (05).
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationBuilder.IS_TAILORED">
            <summary>
            Node bit 3 distinguishes a tailored node, which has no weight value,
            from a node with an explicit (root or default) weight.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationBuilder.rootPrimaryIndexes">
            <summary>
            Indexes of nodes with root primary weights, sorted by primary.
            Compact form of a <see cref="T:System.Collections.Generic.SortedDictionary`2"/> from root primary to node index.
            <para/>
            This is a performance optimization for finding reset positions.
            Without this, we would have to search through the entire nodes list.
            It also allows storing root primary weights in list head nodes,
            without previous index, leaving room in root primary nodes for 32-bit primary weights.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationBuilder.nodes">
            <summary>
            Data structure for assigning tailored weights and CEs.
            Doubly-linked lists of nodes in mostly collation order.
            Each list starts with a root primary node and ends with a nextIndex of 0.
            </summary>
            <remarks>
            When there are any nodes in the list, then there is always a root primary node at index 0.
            This allows some code not to have to check explicitly for nextIndex==0.
            <para/>
            Root primary nodes have 32-bit weights but do not have previous indexes.
            All other nodes have at most 16-bit weights and do have previous indexes.
            <para/>
            Nodes with explicit weights store root collator weights,
            or default weak weights (e.g., secondary 05) for stronger nodes.
            "Tailored" nodes, with the IS_TAILORED bit set,
            do not store explicit weights but rather
            create a difference of a certain strength from the preceding node.
            <para/>
            A root node is followed by either
            - a root/default node of the same strength, or
            - a root/default node of the next-weaker strength, or
            - a tailored node of the same strength.
            <para/>
            A node of a given strength normally implies "common" weights on weaker levels.
            <para/>
            A node with HAS_BEFORE2 must be immediately followed by
            a secondary node with an explicit below-common weight, then a secondary tailored node,
            and later an explicit common-secondary node.
            The below-common weight can be a root weight,
            or it can be BEFORE_WEIGHT16 for tailoring before an implied common weight
            or before the lowest root weight.
            (&amp;[before 2] resets to an explicit secondary node so that
            the following addRelation(secondary) tailors right after that.
            If we did not have this node and instead were to reset on the primary node,
            then addRelation(secondary) would skip forward to the the COMMON_WEIGHT16 node.)
            <para/>
            If the flag is not set, then there are no explicit secondary nodes
            with the common or lower weights.
            <para/>
            Same for HAS_BEFORE3 for tertiary nodes and weights.
            A node must not have both flags set.
            <para/>
            Tailored CEs are initially represented in a CollationDataBuilder as temporary CEs
            which point to stable indexes in this list,
            and temporary CEs stored in a CollationDataBuilder only point to tailored nodes.
            <para/>
            A temporary CE in the ces[] array may point to a non-tailored reset-before-position node,
            until the next relation is added.
            <para/>
            At the end, the tailored weights are allocated as necessary,
            then the tailored nodes are replaced with final CEs,
            and the CollationData is rewritten by replacing temporary CEs with final ones.
            <para/>
            We cannot simply insert new nodes in the middle of the array
            because that would invalidate the indexes stored in existing temporary CEs.
            We need to use a linked graph with stable indexes to existing nodes.
            A doubly-linked list seems easiest to maintain.
            <para/>
            Each node is stored as an long, with its fields stored as bit fields.
            <para/>
            Root primary node:
            - primary weight: 32 bits 63..32
            - reserved/unused/zero: 4 bits 31..28
            <para/>
            Weaker root nodes &amp; tailored nodes:
            - a weight: 16 bits 63..48
              + a root or default weight for a non-tailored node
              + unused/zero for a tailored node
            - index to the previous node: 20 bits 47..28
            <para/>
            All types of nodes:
            - index to the next node: 20 bits 27..8
              + nextIndex=0 in last node per root-primary list
            - reserved/unused/zero bits: bits 7, 4, 2
            - HAS_BEFORE2: bit 6
            - HAS_BEFORE3: bit 5
            - IS_TAILORED: bit 3
            - the difference strength (primary/secondary/tertiary/quaternary): 2 bits 1..0
            <para/>
            We could allocate structs with pointers, but we would have to store them
            in a pointer list so that they can be indexed from temporary CEs,
            and they would require more memory allocations.
            </remarks>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationCompare">
            <since>2012feb14</since>
            <author>Markus W. Scherer</author>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationData">
            <summary>
            Collation data container.
            Immutable data created by a <see cref="T:ICU4N.Impl.Coll.CollationDataBuilder"/>, or loaded from a file,
            or deserialized from API-provided binary data.
            <para/>
            Includes data for the collation base (root/default), aliased if this is not the base.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetCE32FromContexts(System.Int32)">
            <summary>
            Returns the CE32 from two contexts words.
            Access to the defaultCE32 for contraction and prefix matching.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetIndirectCE32(System.Int32)">
            <summary>
            Returns the CE32 for an indirect special CE32 (e.g., with DIGIT_TAG).
            Requires that <paramref name="ce32"/> is special.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetFinalCE32(System.Int32)">
            <summary>
            Returns the CE32 for an indirect special CE32 (e.g., with DIGIT_TAG),
            if <paramref name="ce32"/> is special.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetCEFromOffsetCE32(System.Int32,System.Int32)">
            <summary>
            Computes a CE from <paramref name="c"/>'s <paramref name="ce32"/> which has the <see cref="F:ICU4N.Impl.Coll.Collation.OFFSET_TAG"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetSingleCE(System.Int32)">
            <summary>
            Returns the single CE that c maps to.
            Throws <see cref="T:System.NotSupportedException"/> if <paramref name="c"/> does not map to a single CE.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetFCD16(System.Int32)">
            <summary>
            Returns the FCD16 value for code point <paramref name="c"/>. <paramref name="c"/> must be >= 0.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetFirstPrimaryForGroup(System.Int32)">
            <summary>
            Returns the first primary for the <paramref name="script"/>'s reordering group.
            </summary>
            <returns>The primary with only the first primary lead byte of the group
            (not necessarily an actual root collator primary weight),
            or 0 if the <paramref name="script"/> is unknown
            </returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetLastPrimaryForGroup(System.Int32)">
            <summary>
            Returns the last primary for the <paramref name="script"/>'s reordering group.
            </summary>
            <returns>The last primary of the group
            (not an actual root collator primary weight),
            or 0 if the <paramref name="script"/> is unknown.
            </returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetGroupForPrimary(System.Int64)">
            <summary>
            Finds the reordering group which contains the primary weight.
            </summary>
            <returns>The first script of the group, or -1 if the weight is beyond the last group.</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.MakeReorderRanges(System.Int32[],System.Collections.Generic.IList{System.Int32})">
            <summary>
            Writes the permutation of primary-weight ranges
            for the given reordering of scripts and groups.
            The caller checks for illegal arguments and
            takes care of [DEFAULT] and memory allocation.
            <para/>
            Each list element will be a (limit, offset) pair as described
            for the <see cref="F:ICU4N.Impl.Coll.CollationSettings.reorderRanges"/>.
            The list will be empty if no ranges are reordered.
            </summary>
            <param name="reorder"></param>
            <param name="ranges"></param>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.JAMO_CE32S_LENGTH">
            <seealso cref="F:ICU4N.Impl.Coll.CollationData.jamoCE32s"/>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.trie">
            <summary>Main lookup trie.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.ce32s">
            <summary>
            Array of CE32 values.
            At index 0 there must be CE32(U+0000)
            to support U+0000's special-tag for NUL-termination handling.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.ces">
            <summary>Array of CE values for expansions and <see cref="F:ICU4N.Impl.Coll.Collation.OFFSET_TAG"/>.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.contexts">
            <summary>Array of prefix and contraction-suffix matching data.</summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationData.Base">
            <summary>Base collation data, or null if this data itself is a base.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.jamoCE32s">
            <summary>
            Simple array of <see cref="F:ICU4N.Impl.Coll.CollationData.JAMO_CE32S_LENGTH"/>=19+21+27 CE32s, one per canonical Jamo L/V/T.
            They are normally simple CE32s, rarely expansions.
            For fast handling of <see cref="F:ICU4N.Impl.Coll.Collation.HANGUL_TAG"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.numericPrimary">
            <summary>The single-byte primary weight (xx000000) for numeric collation.</summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationData.CompressibleBytes">
            <summary>256 flags for which primary-weight lead bytes are compressible.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.unsafeBackwardSet">
            <summary>
            Set of code points that are unsafe for starting string comparison after an identical prefix,
            or in backwards CE iteration.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationData.FastLatinTable">
            <summary>
            Fast Latin table for common-Latin-text string comparisons.
            Data structure see class <see cref="T:ICU4N.Impl.Coll.CollationFastLatin"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.fastLatinTableHeader">
            <summary>
            Header portion of the <see cref="P:ICU4N.Impl.Coll.CollationData.FastLatinTable"/>.
            In C++, these are one array, and the header is skipped for mapping characters.
            In .NET, two arrays work better.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.numScripts">
            <summary>
            Data for scripts and reordering groups.
            Uses include building a reordering permutation table and
            providing script boundaries to <see cref="T:ICU4N.Text.AlphabeticIndex`1"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.scriptsIndex">
            <summary>
            The length of scriptsIndex is <see cref="F:ICU4N.Impl.Coll.CollationData.numScripts"/>+16.
            It maps from a Script code or a special reorder code to an entry in <see cref="F:ICU4N.Impl.Coll.CollationData.scriptStarts"/>.
            16 special reorder codes (not all used) are mapped starting at <see cref="F:ICU4N.Impl.Coll.CollationData.numScripts"/>.
            Up to <see cref="F:ICU4N.Impl.Coll.CollationData.MAX_NUM_SPECIAL_REORDER_CODES"/> are codes for special groups like space/punct/digit.
            There are special codes at the end for reorder-reserved primary ranges.
            <para/>
            Multiple scripts may share a range and index, for example Hira &amp; Kana.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.scriptStarts">
            <summary>
            Start primary weight (top 16 bits only) for a group/script/reserved range
            indexed by <see cref="F:ICU4N.Impl.Coll.CollationData.scriptsIndex"/>.
            The first range (separators &amp; terminators) and the last range (trailing weights)
            are not reorderable, and no <see cref="F:ICU4N.Impl.Coll.CollationData.scriptsIndex"/> entry points to them.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationData.RootElements">
            <summary>
            Collation elements in the root collator.
            Used by the <see cref="T:ICU4N.Impl.Coll.CollationRootElements"/> class. The data structure is described there.
            null in a tailoring.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationDataBuilder">
            <summary>
            Low-level <see cref="T:ICU4N.Impl.Coll.CollationData"/> builder.
            Takes (character, CE) pairs and builds them into runtime data structures.
            Supports characters with context prefixes and contraction suffixes.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationDataBuilder.ICEModifier">
            <summary>
            Collation element modifier. Interface class for a modifier
            that changes a tailoring builder's temporary CEs to final CEs.
            Called for every non-special CE32 and every expansion CE.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationDataBuilder.ICEModifier.ModifyCE32(System.Int32)">
            <summary>
            Returns a new CE to replace the non-special input CE32, or else <see cref="F:ICU4N.Impl.Coll.Collation.NoCE"/>.
            </summary>
            <param name="ce32"></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationDataBuilder.ICEModifier.ModifyCE(System.Int64)">
            <summary>
            Returns a new CE to replace the input CE, or else <see cref="F:ICU4N.Impl.Coll.Collation.NoCE"/>.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationDataBuilder.HasMappings">
            <summary>
            <c>true</c> if this builder has mappings (e.g., <see cref="M:ICU4N.Impl.Coll.CollationDataBuilder.Add(J2N.Text.ICharSequence,J2N.Text.ICharSequence,System.Int64[],System.Int32)"/> has been called)
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationDataBuilder.IsAssigned(System.Int32)">
            <returns><c>true</c> if c has CEs in this builder.</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationDataBuilder.EncodeCEs(System.Int64[],System.Int32)">
            <summary>
            Encodes the ces as either the returned ce32 by itself,
            or by storing an expansion, with the returned ce32 referring to that.
            <para/>
            <c>Add(p, s, ces, cesLength) = AddCE32(p, s, EncodeCEs(ces, cesLength))</c>
            </summary>
            <param name="ces"></param>
            <param name="cesLength"></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationDataBuilder.CopyFrom(ICU4N.Impl.Coll.CollationDataBuilder,ICU4N.Impl.Coll.CollationDataBuilder.ICEModifier)">
            <summary>
            Copies all mappings from the src builder, with modifications.
            This builder here must not be built yet, and should be empty.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationDataBuilder.GetCEs(J2N.Text.ICharSequence,System.Int64[],System.Int32)">
            <summary>
            Looks up CEs for s and appends them to the ces array.
            Does not handle normalization: s should be in FCD form.
            <para/>
            Does not write completely ignorable CEs.
            Does not write beyond <see cref="F:ICU4N.Impl.Coll.Collation.MAX_EXPANSION_LENGTH"/>.
            </summary>
            <returns>Incremented cesLength.</returns>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationDataBuilder.ConditionalCE32">
            <summary>
            Build-time context and CE32 for a code point.
            If a code point has contextual mappings, then the default (no-context) mapping
            and all conditional mappings are stored in a singly-linked list
            of ConditionalCE32, sorted by context strings.
            <para/>
            Context strings sort by prefix length, then by prefix, then by contraction suffix.
            Context strings must be unique and in ascending order.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationDataBuilder.ConditionalCE32.Context">
            <summary>
            "\0" for the first entry for any code point, with its default CE32.
            <para/>
            Otherwise one unit with the length of the prefix string,
            then the prefix string, then the contraction suffix.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationDataBuilder.ConditionalCE32.Ce32">
            <summary>
            CE32 for the code point and its context.
            Can be special (e.g., for an expansion) but not contextual (prefix or contraction tag).
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationDataBuilder.ConditionalCE32.DefaultCE32">
            <summary>
            Default CE32 for all contexts with this same prefix.
            Initially <see cref="F:ICU4N.Impl.Coll.Collation.NO_CE32"/>. Set only while building runtime data structures,
            and only on one of the nodes of a sub-list with the same prefix.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationDataBuilder.ConditionalCE32.BuiltCE32">
            <summary>
            CE32 for the built contexts.
            When fetching CEs from the builder, the contexts are built into their runtime form
            so that the normal collation implementation can process them.
            The result is cached in the list head. It is reset when the contexts are modified.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationDataBuilder.ConditionalCE32.Next">
            <summary>
            Index of the next <see cref="T:ICU4N.Impl.Coll.CollationDataBuilder.ConditionalCE32"/>.
            Negative for the end of the list.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationDataBuilder.CopyContractionsFromBaseCE32(System.Text.StringBuilder,System.Int32,System.Int32,ICU4N.Impl.Coll.CollationDataBuilder.ConditionalCE32)">
            <summary>
            Copies base contractions to a list of <see cref="T:ICU4N.Impl.Coll.CollationDataBuilder.ConditionalCE32"/>.
            Sets <c>cond.Next</c> to the index of the first new item
            and returns the index of the last new item.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationDataBuilder.DataBuilderCollationIterator">
            <summary>
            Build-time collation element and character iterator.
            Uses the runtime <see cref="T:ICU4N.Impl.Coll.CollationIterator"/> for fetching CEs for a string
            but reads from the builder's unfinished data structures.
            <para/>
            In particular, this class reads from the unfinished trie
            and has to avoid <see cref="M:ICU4N.Impl.Coll.CollationIterator.NextCE"/> and redirect other
            calls to data.GetCE32() and data.GetCE32FromSupplementary().
            <para/>
            We do this so that we need not implement the collation algorithm
            again for the builder and make it behave exactly like the runtime code.
            That would be more difficult to test and maintain than this indirection.
            Some CE32 tags (for example, the DIGIT_TAG) do not occur in the builder data,
            so the data accesses from those code paths need not be modified.
            <para/>
            This class iterates directly over whole code points
            so that the <see cref="T:ICU4N.Impl.Coll.CollationIterator"/> does not need the finished trie
            for handling the LEAD_SURROGATE_TAG.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataBuilder.IS_BUILDER_JAMO_CE32">
            <summary>
            <see cref="F:ICU4N.Impl.Coll.Collation.BUILDER_DATA_TAG"/>
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationDataReader">
            <summary>
            Collation binary data reader.
            </summary>
            <since>2013feb07</since>
            <author>Markus W. Scherer</author>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_INDEXES_LENGTH">
            <summary>
            Number of int indexes.
            <para/>
            Can be 2 if there are only options.
            Can be 7 or 8 if there are only options and a script reordering.
            The loader treats any index>=indexes[IX_INDEXES_LENGTH] as 0.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_OPTIONS">
            <summary>
            Bits 31..24: numericPrimary, for numeric collation
                 23..16: fast Latin format version (0 = no fast Latin table)
                 15.. 0: options bit set
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_JAMO_CE32S_START">
            <summary>Array offset to Jamo CE32s in ce32s[], or &lt;0 if none.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_REORDER_CODES_OFFSET">
            <summary>Byte offset to int reorderCodes[].</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_REORDER_TABLE_OFFSET">
            <summary>
            Byte offset to uint8_t reorderTable[].
            Empty table if &lt;256 bytes (padding only).
            Otherwise 256 bytes or more (with padding).
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_TRIE_OFFSET">
            <summary>Byte offset to the collation trie. Its length is a multiple of 8 bytes.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_CES_OFFSET">
            <summary>Byte offset to long ces[].</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_CE32S_OFFSET">
            <summary>Byte offset to int ce32s[].</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_ROOT_ELEMENTS_OFFSET">
            <summary>Byte offset to uint32_t rootElements[].</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_CONTEXTS_OFFSET">
            <summary>Byte offset to UChar *contexts[].</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_UNSAFE_BWD_OFFSET">
            <summary>Byte offset to char[] with serialized unsafeBackwardSet.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_FAST_LATIN_TABLE_OFFSET">
            <summary>Byte offset to char fastLatinTable[].</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_SCRIPTS_OFFSET">
            <summary>Byte offset to char scripts[].</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_COMPRESSIBLE_BYTES_OFFSET">
            <summary>
            Byte offset to boolean compressibleBytes[].
            Empty table if &lt;256 bytes (padding only).
            Otherwise 256 bytes or more (with padding).
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationFastLatin">
            <since>2013aug09</since>
            <author>Markus W. Scherer</author>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.Version">
            <summary>
            Fast Latin format version (one byte 1..FF).
            Must be incremented for any runtime-incompatible changes,
            in particular, for changes to any of the following constants.
            <para/>
            When the major version number of the main data format changes,
            we can reset this fast Latin version to 1.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.CONTRACTION">
            <summary>
            Contraction with one fast Latin character.
            Use INDEX_MASK to find the start of the contraction list after the fixed table.
            The first entry contains the default mapping.
            Otherwise use CONTR_CHAR_MASK for the contraction character index
            (in ascending order).
            Use CONTR_LENGTH_SHIFT for the length of the entry
            (1=BAIL_OUT, 2=one CE, 3=two CEs).
            <para/>
            Also, U+0000 maps to a contraction entry, so that the fast path need not
            check for NUL termination.
            It usually maps to a contraction list with only the completely ignorable default value.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.EXPANSION">
            <summary>
            An expansion encodes two CEs.
            Use <see cref="F:ICU4N.Impl.Coll.CollationFastLatin.INDEX_MASK"/> to find the pair of CEs after the fixed table.
            <para/>
            The higher a mini CE value, the easier it is to process.
            For expansions and higher, no context needs to be considered.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.MIN_LONG">
            <summary>
            Encodes one CE with a long/low mini primary (there are 128).
            All potentially-variable primaries must be in this range,
            to make the short-primary path as fast as possible.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.MIN_SHORT">
            <summary>
            Encodes one CE with a short/high primary (there are 60),
            plus a secondary CE if the secondary weight is high.
            Fast handling: At least all letter primaries should be in this range.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.MAX_SHORT">
            <summary>The highest primary weight is reserved for U+FFFF.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.SEC_OFFSET">
            <summary>
            Lookup: Add this offset to secondary weights, except for completely ignorable CEs.
            Must be greater than any special value, e.g., <see cref="F:ICU4N.Impl.Coll.CollationFastLatin.MERGE_WEIGHT"/>.
            The exact value is not relevant for the format version.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.TER_OFFSET">
            <summary>
            Lookup: Add this offset to tertiary weights, except for completely ignorable CEs.
            Must be greater than any special value, e.g., <see cref="F:ICU4N.Impl.Coll.CollationFastLatin.MERGE_WEIGHT"/>.
            Must be greater than case bits as well, so that with combined case+tertiary weights
            plus the offset the tertiary bits does not spill over into the case bits.
            The exact value is not relevant for the format version.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.CONTR_CHAR_MASK">
            <summary>
            Contraction result first word bits 8..0 contain the
            second contraction character, as a char index 0..<see cref="F:ICU4N.Impl.Coll.CollationFastLatin.NUM_FAST_CHARS"/>-1.
            Each contraction list is terminated with a word containing <see cref="F:ICU4N.Impl.Coll.CollationFastLatin.CONTR_CHAR_MASK"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.CONTR_LENGTH_SHIFT">
            <summary>
            Contraction result first word bits 10..9 contain the result length:
            1=bail out, 2=one mini CE, 3=two mini CEs
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.BailOutResult">
            <summary>
            Comparison return value when the regular comparison must be used.
            The exact value is not relevant for the format version.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationFastLatin.GetOptions(ICU4N.Impl.Coll.CollationData,ICU4N.Impl.Coll.CollationSettings,System.Char[])">
            <summary>
            Computes the options value for the compare functions
            and writes the precomputed primary weights.
            Returns -1 if the Latin fastpath is not supported for the data and settings.
            The capacity must be <see cref="F:ICU4N.Impl.Coll.CollationFastLatin.LatinLimit"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationFastLatin.NextPair(System.Char[],System.Int32,System.Int32,J2N.Text.ICharSequence,System.Int32)">
            <summary>
            .NET returns a negative result (use the '~' operator) if sIndex is to be incremented.
            C++ modifies sIndex.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationFastLatinBuilder">
            <since>2013aug09</since>
            <author>Markus W. Scherer</author>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationFastLatinBuilder.CompareInt64AsUnsigned(System.Int64,System.Int64)">
            <summary>
            Compare two signed long values as if they were unsigned.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationFastLatinBuilder.BinarySearch(System.Collections.Generic.IList{System.Int64},System.Int32,System.Int64)">
            <summary>
            Like <see cref="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})"/>.
            </summary>
            <param name="list"></param>
            <param name="limit"></param>
            <param name="ce"></param>
            <returns>The index>=0 where the item was found,
            or the index&lt;0 for inserting the string at ~index in sorted order.</returns>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatinBuilder.miniCEs">
            One 16-bit mini CE per unique CE. 
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationFCD">
            <summary>
            Data and functions for the FCD check fast path.
            <para/>
            The fast path looks at a pair of 16-bit code units and checks
            whether there is an FCD boundary between them;
            there is if the first unit has a trailing ccc=0 (!hasTccc(first))
            or the second unit has a leading ccc=0 (!hasLccc(second)),
            or both.
            When the fast path finds a possible non-boundary,
            then the FCD check slow path looks at the actual sequence of FCD values.
            <para/>
            This is a pure optimization.
            The fast path must at least find all possible non-boundaries.
            If the fast path is too pessimistic, it costs performance.
            <para/>
            For a pair of BMP characters, the fast path tests are precise (1 bit per character).
            <para/>
            For a supplementary code point, the two units are its lead and trail surrogates.
            We set hasTccc(lead)=true if any of its 1024 associated supplementary code points
            has lccc!=0 or tccc!=0.
            We set hasLccc(trail)=true for all trail surrogates.
            As a result, we leave the fast path if the lead surrogate might start a
            supplementary code point that is not FCD-inert.
            (So the fast path need not detect that there is a surrogate pair,
            nor look ahead to the next full code point.)
            <para/>
            HasLccc(lead)=true if any of its 1024 associated supplementary code points
            has lccc!=0, for fast boundary checking between BMP &amp; supplementary.
            <para/>
            HasTccc(trail)=false:
            It should only be tested for unpaired trail surrogates which are FCD-inert.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationFCD.MaybeTibetanCompositeVowel(System.Int32)">
            <summary>
            Tibetan composite vowel signs (U+0F73, U+0F75, U+0F81)
            must be decomposed before reaching the core collation code,
            or else some sequences including them, even ones passing the FCD check,
            do not yield canonically equivalent results.
            <para/>
            This is a fast and imprecise test.
            </summary>
            <param name="c">A code point.</param>
            <returns><c>true</c> if c is U+0F73, U+0F75 or U+0F81 or one of several other Tibetan characters.</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationFCD.IsFCD16OfTibetanCompositeVowel(System.Int32)">
            <summary>
            Tibetan composite vowel signs (U+0F73, U+0F75, U+0F81)
            must be decomposed before reaching the core collation code,
            or else some sequences including them, even ones passing the FCD check,
            do not yield canonically equivalent results.
            <para/>
            They have distinct lccc/tccc combinations: 129/130 or 129/132.
            </summary>
            <param name="fcd16">The FCD value (lccc/tccc combination) of a code point.</param>
            <returns><c>true</c> if fcd16 is from U+0F73, U+0F75 or U+0F81.</returns>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationIterator">
            <summary>
            Collation element iterator and abstract character iterator.
            <para/>
            When a method returns a code point value, it must be in 0..10FFFF,
            except it can be negative as a sentinel value.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationIterator.CEBuffer.INITIAL_CAPACITY">
            <summary>Large enough for CEs of most short strings.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.#ctor(ICU4N.Impl.Coll.CollationData)">
            <summary>
            Partially constructs the iterator.
            In .NET, we cache partially constructed iterators
            and finish their setup when starting to work on text
            (via <see cref="M:ICU4N.Impl.Coll.CollationIterator.Reset(System.Boolean)"/> and the SetText(numeric, ...) methods of subclasses).
            <para/>
            In C++, there is only one constructor, and iterators are
            stack-allocated as needed.
            </summary>
            <param name="d"></param>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.ResetToOffset(System.Int32)">
            <summary>
            Resets the iterator state and sets the position to the specified offset.
            Subclasses must implement, and must call the parent class method,
            or <see cref="M:ICU4N.Impl.Coll.CollationIterator.Reset"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.NextCE">
            <summary>
            Returns the next collation element.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.FetchCEs">
            <summary>
            Fetches all CEs.
            </summary>
            <returns>GetCEsLength()</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.SetCurrentCE(System.Int64)">
            <summary>
            Overwrites the current CE (the last one returned by <see cref="M:ICU4N.Impl.Coll.CollationIterator.NextCE"/>).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.PreviousCE(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Returns the previous collation element.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.NextCodePoint">
            <summary>
            Returns the next code point (with post-increment).
            Public for identical-level comparison and for testing.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.PreviousCodePoint">
            <summary>
            Returns the previous code point (with pre-decrement).
            Public for identical-level comparison and for testing.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.Reset(System.Boolean)">
            <summary>
            Resets the state as well as the numeric setting,
            and completes the initialization.
            Only exists where we reset cached <see cref="T:ICU4N.Impl.Coll.CollationIterator"/> instances
            rather than stack-allocating temporary ones.
            (See also the constructor comments.)
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.HandleNextCE32">
            <summary>
            Returns the next code point and its local CE32 value.
            Returns <see cref="F:ICU4N.Impl.Coll.Collation.FALLBACK_CE32"/> at the end of the text (c&lt;0)
            or when c's CE32 value is to be looked up in the base data (fallback).
            <para/>
            The code point is used for fallbacks, context and implicit weights.
            It is ignored when the returned CE32 is not special (e.g., FFFD_CE32).
            </summary>
            <returns>Returns the code point in bits 63..32 (signed) and the CE32 in bits 31..0.</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.HandleGetTrailSurrogate">
            <summary>
            Called when <see cref="M:ICU4N.Impl.Coll.CollationIterator.HandleNextCE32"/> returns a LEAD_SURROGATE_TAG for a lead surrogate code unit.
            Returns the trail surrogate in that case and advances past it,
            if a trail surrogate follows the lead surrogate.
            Otherwise returns any other code unit and does not advance.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationIterator.ForbidSurrogateCodePoints">
            <summary>
            false if surrogate code points U+D800..U+DFFF
                    map to their own implicit primary weights (for UTF-16),
                    or true if they map to CE(U+FFFD) (for UTF-8)
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.GetDataCE32(System.Int32)">
            <summary>
            Returns the CE32 from the data trie.
            Normally the same as <c>data.GetCE32()</c>, but overridden in the builder.
            Call this only when the faster <c>data.GetCE32()</c> cannot be used.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.PreviousCEUnsafe(System.Int32,System.Collections.Generic.IList{System.Int32})">
            <summary>
            Returns the previous CE when <c>data.IsUnsafeBackward(c, isNumeric)</c>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.AppendNumericCEs(System.Int32,System.Boolean)">
            <summary>
            Turns a string of digits (bytes 0..9)
            into a sequence of CEs that will sort in numeric order.
            <para/>
            Starts from this <paramref name="ce32"/>'s digit value and consumes the following/preceding digits.
            The digits string must not be empty and must not have leading zeros.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.AppendNumericSegmentCEs(J2N.Text.ICharSequence)">
            <summary>
            Turns 1..254 digits into a sequence of CEs.
            Called by <see cref="M:ICU4N.Impl.Coll.CollationIterator.AppendNumericCEs(System.Int32,System.Boolean)"/> for each segment of at most 254 digits.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.SortKeyByteSink.Append(System.Byte[],System.Int32)">
            <param name="bytes">The array of byte.</param>
            <param name="n">The length of bytes to be appended.</param>
        </member>
        <member name="M:ICU4N.Impl.Coll.SortKeyByteSink.AppendBeyondCapacity(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <param name="bytes">The array of byte.</param>
            <param name="start">The start index within the array to be appended.</param>
            <param name="n">The length of bytes to be appended.</param>
            <param name="length">The length of buffer required to store the entire data (i.e. already appended
            bytes + bytes to be appended by this method).</param>
        </member>
        <member name="M:ICU4N.Impl.Coll.LevelCallback.NeedToWrite(ICU4N.Impl.Coll.CollationSortKeyLevel)">
            <param name="level">The next level about to be written to the <see cref="T:ICU4N.Impl.Coll.SortKeyByteSink"/>.</param>
            <returns>true if the level is to be written (the base class implementation always returns true).</returns>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationKeys.levelMasks">
            <summary>
            Map from collation strength (UColAttributeValue) to a mask of Collation.Level bits up to that
            strength, excluding the <see cref="F:ICU4N.Impl.Coll.CollationSortKeyLevel.Case"/> which is independent of the strength, and excluding
            <see cref="F:ICU4N.Impl.Coll.CollationSortKeyLevel.Identical"/> which this function does not write.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationKeys.WriteSortKeyUpToQuaternary(ICU4N.Impl.Coll.CollationIterator,System.Boolean[],ICU4N.Impl.Coll.CollationSettings,ICU4N.Impl.Coll.SortKeyByteSink,ICU4N.Impl.Coll.CollationSortKeyLevel,ICU4N.Impl.Coll.LevelCallback,System.Boolean)">
            <summary>
            Writes the sort key bytes for minLevel up to the iterator data's strength. Optionally writes
            the case level. Stops writing levels when callback.NeedToWrite(level) returns false.
            Separates levels with the <see cref="F:ICU4N.Impl.Coll.Collation.LevelSeparatorByte"/> but does not write a <see cref="F:ICU4N.Impl.Coll.Collation.TerminatorByte"/>.
            </summary>
            <param name="iter"></param>
            <param name="compressibleBytes"></param>
            <param name="settings"></param>
            <param name="sink"></param>
            <param name="minLevel"></param>
            <param name="callback"></param>
            <param name="preflight"></param>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationLoader">
            <summary>
            Convenience string denoting the Collation data tree
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationLoader.ASCII">
            <summary>
            Simpler/faster methods for ASCII than ones based on Unicode data.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationRoot">
            <summary>
            Collation root provider.
            </summary>
            <since>2012dec17</since>
            <author>Markus W. Scherer</author>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationRootElements">
            <summary>
            Container and access methods for collation elements and weights
            that occur in the root collator.
            Needed for finding boundaries for building a tailoring.
            <para/>
            This class takes and returns 16-bit secondary and tertiary weights.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.PrimarySentinel">
            <summary>
            Higher than any root primary.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.SecondaryTertiaryDeltaFlag">
            <summary>
            Flag in a root element, set if the element contains secondary &amp; tertiary weights,
            rather than a primary.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.PrimaryStepMask">
            <summary>
            Mask for getting the primary range step value from a primary-range-end element.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.IX_FIRST_TERTIARY_INDEX">
            <summary>
            Index of the first CE with a non-zero tertiary weight.
            Same as the start of the compact root elements table.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.IX_FIRST_SECONDARY_INDEX">
            <summary>
            Index of the first CE with a non-zero secondary weight.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.IX_FIRST_PRIMARY_INDEX">
            <summary>
            Index of the first CE with a non-zero primary weight.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.IX_COMMON_SEC_AND_TER_CE">
            <summary>
            Must match Collation.COMMON_SEC_AND_TER_CE.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.IX_SEC_TER_BOUNDARIES">
            <summary>
            Secondary &amp; tertiary boundaries.
            Bits 31..24: [fixed last secondary common byte 45]
            Bits 23..16: [fixed first ignorable secondary byte 80]
            Bits 15.. 8: reserved, 0
            Bits  7.. 0: [fixed first ignorable tertiary byte 3C]
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.IX_COUNT">
            <summary>
            The current number of indexes.
            Currently the same as elements[IX_FIRST_TERTIARY_INDEX].
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.TertiaryBoundary">
            <summary>
            Gets the boundary between tertiary weights of primary/secondary CEs
            and those of tertiary CEs.
            This is the upper limit for tertiaries of primary/secondary CEs.
            This minus one is the lower limit for tertiaries of tertiary CEs.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.FirstTertiaryCE">
            <summary>
            Gets the first assigned tertiary CE.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.LastTertiaryCE">
            <summary>
            Gets the last assigned tertiary CE.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.LastCommonSecondary">
            <summary>
            Gets the last common secondary weight.
            This is the lower limit for secondaries of primary CEs.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.SecondaryBoundary">
            <summary>
            Gets the boundary between secondary weights of primary CEs
            and those of secondary CEs.
            This is the upper limit for secondaries of primary CEs.
            This minus one is the lower limit for secondaries of secondary CEs.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.FirstSecondaryCE">
            <summary>
            Gets the first assigned secondary CE.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.LastSecondaryCE">
            <summary>
            Gets the last assigned secondary CE.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.FirstPrimary">
            <summary>
            Gets the first assigned primary weight.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.FirstPrimaryCE">
            <summary>
            Gets the first assigned primary CE.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.LastCEWithPrimaryBefore(System.Int64)">
            <summary>
            Returns the last root CE with a primary weight before <paramref name="p"/>.
            Intended only for reordering group boundaries.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.FirstCEWithPrimaryAtLeast(System.Int64)">
            <summary>
            Returns the first root CE with a primary weight of at least <paramref name="p"/>.
            Intended only for reordering group boundaries.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.GetPrimaryBefore(System.Int64,System.Boolean)">
            <summary>
            Returns the primary weight before <paramref name="p"/>.
            <paramref name="p"/> must be greater than the first root primary.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.GetSecondaryBefore(System.Int64,System.Int32)">
            <summary>Returns the secondary weight before [p, s].</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.GetTertiaryBefore(System.Int64,System.Int32,System.Int32)">
            <summary>Returns the tertiary weight before [p, s, t].</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.FindPrimary(System.Int64)">
            <summary>
            Finds the index of the input primary.
            <paramref name="p"/> must occur as a root primary, and must not be 0.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.GetPrimaryAfter(System.Int64,System.Int32,System.Boolean)">
            <summary>
            Returns the primary weight after <paramref name="p"/> where index=FindPrimary(p).
            <paramref name="p"/> must be at least the first root primary.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.GetSecondaryAfter(System.Int32,System.Int32)">
            <summary>
            Returns the secondary weight after [p, s] where index=FindPrimary(p)
            except use index=0 for p=0.
            <para/>
            Must return a weight for every root [p, s] as well as for every weight
            returned by GetSecondaryBefore(). If p!=0 then s can be BEFORE_WEIGHT16.
            <para/>
            Exception: [0, 0] is handled by the CollationBuilder:
            Both its lower and upper boundaries are special.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.GetTertiaryAfter(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the tertiary weight after [p, s, t] where index=FindPrimary(p)
            except use index=0 for p=0.
            <para/>
            Must return a weight for every root [p, s, t] as well as for every weight
            returned by GetTertiaryBefore(). If s!=0 then t can be BEFORE_WEIGHT16.
            <para/>
            Exception: [0, 0, 0] is handled by the CollationBuilder:
            Both its lower and upper boundaries are special.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.GetFirstSecTerForPrimary(System.Int32)">
            <summary>
            Returns the first secondary &amp; tertiary weights for p where index=findPrimary(p)+1.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.FindP(System.Int64)">
            <summary>
            Finds the largest index i where elements[i]&lt;=p.
            Requires first primary&lt;=p&lt;0xffffff00 (PRIMARY_SENTINEL).
            Does not require that p is a root collator primary.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.elements">
            <summary>
            Data structure: See ICU4C source/i18n/collationrootelements.h.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationRuleParser.Position">
            <summary>Special reset positions.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRuleParser.POS_LEAD">
            <summary>
            First character of contractions that encode special reset positions.
            U+FFFE cannot be tailored via rule syntax.
            <para/>
            The second contraction character is <see cref="F:ICU4N.Impl.Coll.CollationRuleParser.POS_BASE"/> + <see cref="T:ICU4N.Impl.Coll.CollationRuleParser.Position"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRuleParser.POS_BASE">
            <summary>
            Base for the second character of contractions that encode special reset positions.
            Braille characters U+28xx are printable and normalization-inert.
            </summary>
            <seealso cref="F:ICU4N.Impl.Coll.CollationRuleParser.POS_LEAD"/>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRuleParser.ISink.AddReset(ICU4N.Text.CollationStrength,J2N.Text.ICharSequence)">
            <summary>
            Adds a reset.
            <para/>
            strength=<see cref="F:ICU4N.Text.CollationStrength.Identical"/> for &amp;str.
            <para/>
            strength=<see cref="F:ICU4N.Text.CollationStrength.Primary"/>/<see cref="F:ICU4N.Text.CollationStrength.Secondary"/>/<see cref="F:ICU4N.Text.CollationStrength.Tertiary"/> for &amp;[before n]str where n=1/2/3.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRuleParser.ISink.AddRelation(ICU4N.Text.CollationStrength,J2N.Text.ICharSequence,J2N.Text.ICharSequence,System.String)">
            <summary>
            Adds a relation with strength and prefix | str / extension.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRuleParser.#ctor(ICU4N.Impl.Coll.CollationData)">
            <summary>
            Constructor.
            The <see cref="T:ICU4N.Impl.Coll.CollationRuleParser.ISink"/> must be set before parsing.
            The <see cref="T:ICU4N.Impl.Coll.CollationRuleParser.IImporter"/> can be set, otherwise [import locale] syntax is not supported.
            </summary>
            <param name="baseData"></param>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRuleParser.SetSink(ICU4N.Impl.Coll.CollationRuleParser.ISink)">
            <summary>
            Sets the pointer to a <see cref="T:ICU4N.Impl.Coll.CollationRuleParser.ISink"/> object.
            The pointer is aliased: Pointer copy without cloning or taking ownership.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRuleParser.SetImporter(ICU4N.Impl.Coll.CollationRuleParser.IImporter)">
            <summary>
            Sets the pointer to an <see cref="T:ICU4N.Impl.Coll.CollationRuleParser.IImporter"/> object.
            The pointer is aliased: Pointer copy without cloning or taking ownership.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRuleParser.STRENGTH_MASK">
            <summary>UCOL_PRIMARY=0 .. UCOL_IDENTICAL=15</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRuleParser.ParseSpecialPosition(System.Int32,System.Text.StringBuilder)">
            <summary>
            Sets str to a contraction of U+FFFE and (U+2800 + Position).
            </summary>
            <param name="i"></param>
            <param name="str"></param>
            <returns>Rule index after the special reset position.</returns>
            <exception cref="T:System.FormatException"/>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRuleParser.GetReorderCode(System.String)">
            <summary>
            Gets a script or reorder code from its string representation.
            </summary>
            <param name="word"></param>
            <returns>The script/reorder code, or -1 if not recognized.</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRuleParser.IsSyntaxChar(System.Int32)">
            <summary>
            ASCII [:P:] and [:S:]:
            [\u0021-\u002F \u003A-\u0040 \u005B-\u0060 \u007B-\u007E]
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationSettings">
            <summary>
            Collation settings/options/attributes.
            These are the values that can be changed via API.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.CheckFCD">
            <summary>
            Options bit 0: Perform the FCD check on the input text and deliver normalized text.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.Numeric">
            <summary>
            Options bit 1: Numeric collation.
            Also known as CODAN = COllate Digits As Numbers.
            <para/>
            Treat digit sequences as numbers with CE sequences in numeric order,
            rather than returning a normal CE for each digit.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.Shifted">
            <summary>
            "Shifted" alternate handling, see <see cref="F:ICU4N.Impl.Coll.CollationSettings.AlternateMask"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.AlternateMask">
            <summary>
            Options bits 3..2: Alternate-handling mask. 0 for non-ignorable.
            Reserve values 8 and 0xc for shift-trimmed and blanked.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.MaxVariableShift">
            <summary>
            Options bits 6..4: The 3-bit maxVariable value bit field is shifted by this value.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.MaxVariableMask">
            <summary>maxVariable options bit mask before shifting.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.UpperFirst">
            <summary>
            Options bit 8: Sort uppercase first if caseLevel or caseFirst is on.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.CaseFirst">
            <summary>
            Options bit 9: Keep the case bits in the tertiary weight (they trump other tertiary values)
            unless case level is on (when they are *moved* into the separate case level).
            By default, the case bits are removed from the tertiary weight (ignored).
            <para/>
            When <see cref="F:ICU4N.Impl.Coll.CollationSettings.CaseFirst"/> is off, <see cref="F:ICU4N.Impl.Coll.CollationSettings.UpperFirst"/> must be off too, corresponding to
            the tri-value UCOL_CASE_FIRST attribute: UCOL_OFF vs. UCOL_LOWER_FIRST vs. UCOL_UPPER_FIRST.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.CaseFirstAndUpperMask">
            <summary>
            Options bit mask for caseFirst and upperFirst, before shifting.
            Same value as caseFirst==upperFirst.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.CaseLevel">
            <summary>
            Options bit 10: Insert the case level between the secondary and tertiary levels.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.BackwardSecondary">
            <summary>
            Options bit 11: Compare secondary weights backwards. ("French secondary")
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.StrengthShift">
            <summary>
            Options bits 15..12: The 4-bit strength value bit field is shifted by this value.
            It is the top used bit field in the options. (No need to mask after shifting.)
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.StrengthMask">
            <summary>Strength options bit mask before shifting.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.MaxVariableSpace">
            <summary>maxVariable values</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationSettings.SetFlag(System.Int32,System.Boolean)">
            <summary>Sets the options bit for an on/off attribute.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationSettings.IsTertiaryWithCaseBits(System.Int32)">
            <summary>
            Include case bits in the tertiary level if caseLevel=off and caseFirst!=off.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.options">
            <summary>CHECK_FCD etc.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.variableTop">
            <summary>Variable-top primary weight.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.reorderTable">
            <summary>
            256-byte table for reordering permutation of primary lead bytes; null if no reordering.
            A 0 entry at a non-zero index means that the primary lead byte is "split"
            (there are different offsets for primaries that share that lead byte)
            and the reordering offset must be determined via the <see cref="F:ICU4N.Impl.Coll.CollationSettings.reorderRanges"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.minHighNoReorder">
            <summary>Limit of last reordered range. 0 if no reordering or no split bytes.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.reorderRanges">
            <summary>
            Primary-weight ranges for script reordering,
            to be used by <see cref="M:ICU4N.Impl.Coll.CollationSettings.Reorder(System.Int64)"/> for split-reordered primary lead bytes.
            <para/>
            Each entry is a (limit, offset) pair.
            The upper 16 bits of the entry are the upper 16 bits of the
            exclusive primary limit of a range.
            Primaries between the previous limit and this one have their lead bytes
            modified by the signed offset (-0xff..+0xff) stored in the lower 16 bits.
            <para/>
            <see cref="M:ICU4N.Impl.Coll.CollationData.MakeReorderRanges(System.Int32[],System.Collections.Generic.IList{System.Int32})"/> writes a full list where the first range
            (at least for terminators and separators) has a 0 offset.
            The last range has a non-zero offset.
            <see cref="F:ICU4N.Impl.Coll.CollationSettings.minHighNoReorder"/> is set to the limit of that last range.
            <para/>
            In the settings object, the initial ranges before the first split lead byte
            are omitted for efficiency; they are handled by <see cref="M:ICU4N.Impl.Coll.CollationSettings.Reorder(System.Int64)"/> via the <see cref="F:ICU4N.Impl.Coll.CollationSettings.reorderTable"/>.
            If there are no split-reordered lead bytes, then no ranges are needed.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.reorderCodes">
            <summary>Array of reorder codes; ignored if length == 0.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.fastLatinOptions">
            <summary>Options for CollationFastLatin. Negative if disabled.</summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationTailoring">
            <summary>
            Collation tailoring data &amp; settings.
            This is a container of values for a collation tailoring
            built from rules or deserialized from binary data.
            <para/>
            It is logically immutable: Do not modify its values.
            The fields are public for convenience.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationTailoring.SetRules(System.String)">
            Not thread-safe, call only before sharing. 
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationTailoring.SetRulesResource(ICU4N.Util.UResourceBundle)">
            Not thread-safe, call only before sharing. 
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationWeights">
            <summary>
            Allocates n collation element weights between two exclusive limits.
            Used only internally by the collation tailoring builder.
            </summary>
            <since>2001mar08</since>
            <author>Markus W. Scherer</author>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationWeights.AllocWeights(System.Int64,System.Int64,System.Int32)">
            <summary>
            Determine heuristically
            what ranges to use for a given number of weights between (excluding)
            two limits.
            </summary>
            <param name="lowerLimit">A collation element weight; the ranges will be filled to cover
            weights greater than this one.</param>
            <param name="upperLimit">A collation element weight; the ranges will be filled to cover
            weights less than this one.</param>
            <param name="n">The number of collation element weights w necessary such that
            lowerLimit&lt;w&lt;upperLimit in lexical order.</param>
            <returns><c>true</c> if it is possible to fit n elements between the limits.</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationWeights.NextWeight">
            <summary>
            Given a set of ranges calculated by <see cref="M:ICU4N.Impl.Coll.CollationWeights.AllocWeights(System.Int64,System.Int64,System.Int32)"/>,
            iterate through the weights.
            The ranges are modified to keep the current iteration state.
            </summary>
            <returns>The next weight in the ranges, or 0xffffffff if there is none left.</returns>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationWeights.WeightRange">
            <internal/>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationWeights.CountBytes(System.Int32)">
            <returns>Number of usable byte values for byte <paramref name="idx"/>.</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationWeights.GetWeightRanges(System.Int64,System.Int64)">
            <summary>
            Takes two CE weights and calculates the
            possible ranges of weights between the two limits, excluding them.
            For weights with up to 4 bytes there are up to 2*4-1=7 ranges.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.FCDIterCollationIterator">
            <summary>
            Incrementally checks the input text for FCD and normalizes where necessary.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.FCDIterCollationIterator.SwitchToForward">
            <summary>
            Switches to forward checking if possible.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.FCDIterCollationIterator.NextSegment">
            <summary>
            Extends the FCD text segment forward or normalizes around pos.
            </summary>
            <returns><c>true</c> if success.</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.FCDIterCollationIterator.SwitchToBackward">
            <summary>
            Switches to backward checking.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.FCDIterCollationIterator.PreviousSegment">
            <summary>
            Extends the FCD text segment backward or normalizes around pos.
            </summary>
            <returns><c>true</c> if success.</returns>
        </member>
        <member name="F:ICU4N.Impl.Coll.FCDIterCollationIterator.State.IterCheckFwd">
            <summary>
            The input text [start..(iter index)[ passes the FCD check.
            Moving forward checks incrementally.
            pos &amp; limit are undefined.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.FCDIterCollationIterator.State.IterCheckBwd">
            <summary>
            The input text [(iter index)..limit[ passes the FCD check.
            Moving backward checks incrementally.
            start &amp; pos are undefined.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.FCDIterCollationIterator.State.IterInFCDSegment">
            <summary>
            The input text [start..limit[ passes the FCD check.
            pos tracks the current text index.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.FCDIterCollationIterator.State.InNormIterAtLimit">
            <summary>
            The input text [start..limit[ failed the FCD check and was normalized.
            pos tracks the current index in the normalized string.
            The text iterator is at the limit index.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.FCDIterCollationIterator.State.InNormIterAtStart">
            <summary>
            The input text [start..limit[ failed the FCD check and was normalized.
            pos tracks the current index in the normalized string.
            The text iterator is at the start index.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.FCDUTF16CollationIterator">
            <summary>
            Incrementally checks the input text for FCD and normalizes where necessary.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.FCDUTF16CollationIterator.#ctor(ICU4N.Impl.Coll.CollationData)">
            <summary>
            Partial constructor, see <see cref="M:ICU4N.Impl.Coll.CollationIterator.#ctor(ICU4N.Impl.Coll.CollationData)"/>
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.FCDUTF16CollationIterator.SwitchToForward">
            <summary>
            Switches to forward checking if possible.
            To be called when checkDir &lt; 0 || (checkDir == 0 &amp;&amp; pos == limit).
            Returns with checkDir &gt; 0 || (checkDir == 0 &amp;&amp; pos != limit).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.FCDUTF16CollationIterator.NextSegment">
            <summary>
            Extend the FCD text segment forward or normalize around pos.
            To be called when checkDir > 0 &amp;&amp; pos != limit.
            Returns with checkDir == 0 and pos != limit.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.FCDUTF16CollationIterator.SwitchToBackward">
            <summary>
            Switches to backward checking.
            To be called when checkDir &gt; 0 || (checkDir == 0 &amp;&amp; pos == start).
            Returns with checkDir &lt; 0 || (checkDir == 0 &amp;&amp; pos != start).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.FCDUTF16CollationIterator.PreviousSegment">
            <summary>
            Extend the FCD text segment backward or normalize around pos.
            To be called when checkDir &lt; 0 &amp;&amp; pos != start.
            Returns with checkDir == 0 and pos != start.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.IterCollationIterator">
            <summary>
            <see cref="T:ICU4N.Text.UCharacterIterator"/>-based collation element and character iterator.
            Handles normalized text, with length or NUL-terminated.
            Unnormalized text is handled by a subclass.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.SharedObject">
             <summary>
             Base class for shared, reference-counted, auto-deleted objects.
             .NET subclasses are mutable and must implement <see cref="M:ICU4N.Impl.Coll.SharedObject.Clone"/>.
            
             <para/>In C++, the SharedObject base class is used for both memory and ownership management.
             In .NET, memory management (deletion after last reference is gone)
             is up to the garbage collector,
             but the reference counter is still used to see whether the referent is the sole owner.
            
             <para/>Usage:
             <code>
             public class S : SharedObject
             {
                 public override void Clone() { ... }
             }
            
             // Either use the nest class Reference (which costs an extra allocation),
             // or duplicate its code in the class that uses S
             // (which duplicates code and is more error-prone).
             public class U
             {
                 // For read-only access, use s.ReadOnly().
                 // For writable access, use S ownedS = s.CopyOnWrite();
                 private SharedObject.Reference&lt;S&gt; s;
                 // Returns a writable version of s.
                 // If there is exactly one owner, then s itself is returned.
                 // If there are multiple owners, then s is replaced with a clone,
                 // and that is returned.
                 private S GetOwnedS()
                 {
                     return s.CopyOnWrite();
                 }
                 
                 public object Clone()
                 {
                     ...
                     c.s = s.Clone();
                     ...
                 }
             }
            
             public class V
             {
                 // For read-only access, use s directly.
                 // For writable access, use S ownedS = GetOwnedS();
                 private S s;
                 // Returns a writable version of s.
                 // If there is exactly one owner, then s itself is returned.
                 // If there are multiple owners, then s is replaced with a clone,
                 // and that is returned.
                 private S GetOwnedS()
                 {
                     if(s.GetRefCount() > 1)
                     {
                         S ownedS = s.Clone();
                         s.RemoveRef();
                         s = ownedS;
                         ownedS.AddRef();
                     }
                     return s;
                 }
                 
                 public U Clone()
                 {
                     ...
                     s.AddRef();
                     ...
                 }
                 
                 ~V()
                 {
                     ...
                     if(s != null) {
                         s.RemoveRef();
                         s = null;
                     }
                     ...
                 }
             }
             </code>
            
             Either use only .NET memory management, or use AddRef()/RemoveRef().
             Sharing requires reference-counting.
             </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.SharedObject.Reference`1">
            <summary>
            Similar to a smart pointer, basically a port of the static methods of C++ SharedObject.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.SharedObject.Reference`1.CopyOnWrite">
            <summary>
            Returns a writable version of the reference.
            If there is exactly one owner, then the reference itself is returned.
            If there are multiple owners, then the reference is replaced with a clone,
            and that is returned.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.SharedObject.#ctor">
            <summary>Initializes refCount to 0.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.SharedObject.Clone">
            <summary>Initializes refCount to 0.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.SharedObject.AddRef">
            <summary>
            Increments the number of references to this object. Thread-safe.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.SharedObject.RemoveRef">
            <summary>
            Decrements the number of references to this object,
            and auto-deletes "this" if the number becomes 0. Thread-safe.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.SharedObject.RefCount">
            <summary>
            Returns the reference counter. Uses a memory barrier.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.TailoredSet">
             <summary>
             Finds the set of characters and strings that sort differently in the tailoring
             from the base data.
            
             <para/>Every mapping in the tailoring needs to be compared to the base,
             because some mappings are copied for optimization, and
             all contractions for a character are copied if any contractions for that character
             are added, modified or removed.
            
             <para/>It might be simpler to re-parse the rule string, but:
             <list type="bullet">
                 <item><description>That would require duplicating some of the from-rules builder code.</description></item>
                 <item><description>That would make the runtime code depend on the builder.</description></item>
                 <item><description>That would only work if we have the rule string, and we allow users to
                                    omit the rule string from data files.</description></item>
             </list>
             </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.UTF16CollationIterator">
            <summary>
            UTF-16 collation element and character iterator.
            Handles normalized UTF-16 text, with length or NUL-terminated.
            Unnormalized text is handled by a subclass.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.UTF16CollationIterator.#ctor(ICU4N.Impl.Coll.CollationData)">
            <summary>
            Partial constructor, see <see cref="M:ICU4N.Impl.Coll.CollationIterator.#ctor(ICU4N.Impl.Coll.CollationData)"/>
            </summary>
        </member>
        <member name="T:ICU4N.Text.AlphabeticIndex`1">
            <summary>
            <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> supports the creation of a UI index appropriate for a given language.
            It can support either direct use, or use with a client that doesn't support localized collation.
            </summary>
            <remarks>
            The following is an example of what an index might look like in a UI:
            <code>
             <b>... A B C D E F G H I J K L M N O P Q R S T U V W X Y Z  ...</b>
             
             <b>A</b>
                Addison
                Albertson
                Azensky
             <b>B</b>
                Baecker
             ...
            </code>
            <para/>
            The class can generate a list of labels for use as a UI "index", that is, a list of
            clickable characters (or character sequences) that allow the user to see a segment
            (bucket) of a larger "target" list. That is, each label corresponds to a bucket in
            the target list, where everything in the bucket is greater than or equal to the character
            (according to the locale's collation). Strings can be added to the index;
            they will be in sorted order in the right bucket.
            <para/>
            The class also supports having buckets for strings before the first (underflow),
            after the last (overflow), and between scripts (inflow). For example, if the index
            is constructed with labels for Russian and English, Greek characters would fall
            into an inflow bucket between the other two scripts.
            <para/>
            <em>Note:</em> If you expect to have a lot of ASCII or Latin characters
            as well as characters from the user's language,
            then it is a good idea to call <see cref="M:ICU4N.Text.AlphabeticIndex`1.AddLabels(ICU4N.Globalization.UCultureInfo[])"/> with <c>new UCultureInfo("en")</c>.
            <h2>Direct Use</h2>
            The following shows an example of building an index directly.
            The "show..." methods below are just to illustrate usage.
            <code>
            // Create a simple index where the values for the strings are Integers, and add the strings
            
            AlphabeticIndex&lt;int&gt; index = new AlphabeticIndex&lt;int&gt;(desiredLocale).AddLabels(additionalLocale);
            int counter = 0;
            foreach (string item in test)
            {
                index.AddRecord(item, counter++);
            }
            ...
            // Show index at top. We could skip or gray out empty buckets
            
            foreach (AlphabeticIndex&lt;int&gt;.Bucket bucket in index)
            {
                if (showAll || bucket.Count != 0)
                {
                    ShowLabelAtTop(UI, bucket.Label);
                }
            }
            ...
            // Show the buckets with their contents, skipping empty buckets
            
            foreach (AlphabeticIndex&lt;int&gt;.Bucket bucket in index)
            {
                if (bucket.Count != 0)
                {
                    ShowLabelInList(UI, bucket.Label);
                    foreach (AlphabeticIndex&lt;int&gt;.Record item in bucket)
                    {
                        ShowIndexedItem(UI, item.Name, item.Data);
                    }
                }
            }
            </code>
            The caller can build different UIs using this class.
            For example, an index character could be omitted or grayed-out
            if its bucket is empty. Small buckets could also be combined based on size, such as:
            <code>
            <b>... A-F G-N O-Z ...</b>
            </code>
            <h2>Client Support</h2>
            Callers can also use the <see cref="T:ICU4N.Text.ImmutableIndex`1"/>, or the <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> itself,
            to support sorting on a client that doesn't support <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> functionality.
            <para/>
            The <see cref="T:ICU4N.Text.ImmutableIndex`1"/> is both immutable and thread-safe.
            The corresponding <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> methods are not thread-safe because
            they "lazily" build the index buckets.
            <list type="bullet">
                <item><description>
                    <see cref="M:ICU4N.Text.ImmutableIndex`1.GetBucket(System.Int32)"/> provides random access to all
                    buckets and their labels and label types.
                </description></item>
                <item><description>
                    <see cref="M:ICU4N.Text.AlphabeticIndex`1.GetBucketLabels"/> or the bucket iterator on either class
                    can be used to get a list of the labels,
                    such as "...", "A", "B",..., and send that list to the client.
                </description></item>
                <item><description>
                    When the client has a new name, it sends that name to the server.
                    The server needs to call the following methods,
                    and communicate the bucketIndex and collationKey back to the client.
                    
                    <code>
                    int bucketIndex = index.GetBucketIndex(name);
                    string label = immutableIndex.GetBucket(bucketIndex).Label;  // optional
                    RawCollationKey collationKey = collator.GetRawCollationKey(name, null);
                    </code>
                    
                </description></item>
                <item><description>
                    The client would put the name (and associated information) into its bucket for bucketIndex. The collationKey is a
                    sequence of bytes that can be compared with a binary compare, and produce the right localized result.
                </description></item>
            </list>
            </remarks>
            <typeparam name="T">Data type of bucket data.</typeparam>
            <author>Mark Davis</author>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.AlphabeticIndex`1.BASE">
            <summary>
            Prefix string for Chinese index buckets.
            See http://unicode.org/repos/cldr/trunk/specs/ldml/tr35-collation.html#Collation_Indexes
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.#ctor(ICU4N.Globalization.UCultureInfo)">
            <summary>
            Create the index object.
            </summary>
            <param name="locale">The locale for the index.</param>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Create the index object.
            </summary>
            <param name="locale">The locale for the index.</param>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.#ctor(ICU4N.Text.RuleBasedCollator)">
            <summary>
            Create an <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> that uses a specific collator.
            <para/>
            The index will be created with no labels; the <see cref="M:ICU4N.Text.AlphabeticIndex`1.AddLabels(System.Globalization.CultureInfo[])"/> function (or overload) must be called
            after creation to add the desired labels to the index.
            <para/>
            The index will work directly with the supplied collator. If the caller will need to
            continue working with the collator it should be cloned first, so that the
            collator provided to the <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> remains unchanged after creation of the index.
            </summary>
            <param name="collator">The collator to use to order the contents of this index.</param>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.#ctor(ICU4N.Globalization.UCultureInfo,ICU4N.Text.RuleBasedCollator)">
            <summary>
            Internal constructor containing implementation used by public constructors.
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.AddLabels(ICU4N.Text.UnicodeSet)">
            <summary>
            Add more index characters (aside from what are in the locale)
            </summary>
            <param name="additions">Additional characters to add to the index, such as A-Z.</param>
            <returns>This, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.AddLabels(ICU4N.Globalization.UCultureInfo[])">
            <summary>
            Add more index characters (aside from what are in the locale)
            </summary>
            <param name="additions">Additional characters to add to the index, such as those in Swedish.</param>
            <returns>This, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.AddLabels(System.Globalization.CultureInfo[])">
            <summary>
            Add more index characters (aside from what are in the locale)
            </summary>
            <param name="additions">Additional characters to add to the index, such as those in Swedish.</param>
            <returns>This, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.SetOverflowLabel(System.String)">
            <summary>
            Set the overflow label.
            </summary>
            <param name="overflowLabel">See <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> class description.</param>
            <returns>This, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.UnderflowLabel">
            <summary>
            Get the default label used in the IndexCharacters' locale for underflow, eg the last item in: X Y Z ...
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.SetUnderflowLabel(System.String)">
            <summary>
            Set the underflowLabel label.
            </summary>
            <param name="underflowLabel">See <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> class description.</param>
            <returns>This, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.OverflowLabel">
            <summary>
            Get the default label used in the IndexCharacters' locale for overflow, eg the first item in: ... A B C
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.SetInflowLabel(System.String)">
            <summary>
            Set the inflowLabel label.
            </summary>
            <param name="inflowLabel">See <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> class description.</param>
            <returns>This, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.InflowLabel">
            <summary>
            Get the default label used for abbreviated buckets <i>between</i> other labels. For example, consider the labels
            for Latin and Greek are used: X Y Z ... &#x0391; &#x0392; &#x0393;.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.MaxLabelCount">
            <summary>
            Get the limit on the number of labels in the index. The number of buckets can be slightly larger: see <see cref="P:ICU4N.Text.AlphabeticIndex`1.BucketCount"/>.
            Returns maximum number of labels.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.SetMaxLabelCount(System.Int32)">
            <summary>
            Set a limit on the number of labels in the index. The number of buckets can be slightly larger: see
            <see cref="P:ICU4N.Text.AlphabeticIndex`1.BucketCount"/>.
            </summary>
            <param name="maxLabelCount">
            Set the maximum number of labels. Currently, if the number is exceeded, then every
            nth item is removed to bring the count down. A more sophisticated mechanism may be available in the
            future.
            </param>
            <returns>This, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.InitLabels">
            <summary>
            Determine the best labels to use. This is based on the exemplars, but we also process to make sure that they are unique,
            and sort differently, and that the overall list is small enough.
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.AddIndexExemplars(ICU4N.Globalization.UCultureInfo)">
            <summary>
            This method is called to get the index exemplars. Normally these come from the <paramref name="locale"/> directly,
            but if they aren't available, we have to synthesize them.
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.AddChineseIndexCharacters">
            <summary>
            Add Chinese index characters from the tailoring.
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.Separated(System.String)">
            <summary>
            Return the string with interspersed CGJs. Input must have more than 2 codepoints.
            <para/>
            This is used to test whether contractions sort differently from their components.
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.BuildImmutableIndex">
            <summary>
            Builds an immutable, thread-safe version of this instance, without data records.
            </summary>
            <returns>An immutable index instance.</returns>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.GetBucketLabels">
            <summary>
            Get the labels.
            </summary>
            <returns>The list of bucket labels, after processing.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.Collator">
            <summary>
            Get a clone of the collator used internally. Note that for performance reasons, the clone is only done once, and
            then stored. The next time it is accessed, the same instance is returned.
            <para/>
            <b><i>Don't use this property across threads if you are changing the settings on the collator, at least not without
            synchronizing.</i></b>
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.AddRecord(System.String,`0)">
            <summary>
            Add a record (name and data) to the index. The name will be used to sort the items into buckets, and to sort
            within the bucket. Two records may have the same name. When they do, the sort order is according to the order added:
            the first added comes first.
            </summary>
            <param name="name">Name, such as a name.</param>
            <param name="data">Data, such as an address or link.</param>
            <returns>this, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.GetBucketIndex(System.String)">
            <summary>
            Get the bucket number for the given name. This routine permits callers to implement their own bucket handling
            mechanisms, including client-server handling. For example, when a new name is created on the client, it can ask
            the server for the bucket for that name, and the sortkey (using <see cref="P:ICU4N.Text.AlphabeticIndex`1.Collator"/>). Once the client has that
            information, it can put the name into the right bucket, and sort it within that bucket, without having access to
            the index or collator.
            <para/>
            Note that the bucket number (and sort key) are only valid for the settings of the current <see cref="T:ICU4N.Text.AlphabeticIndex`1"/>; if
            those are changed, then the bucket number and sort key must be regenerated.
            </summary>
            <param name="name">Name, such as a name.</param>
            <returns>The bucket index for the name.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.ClearRecords">
            <summary>
            Clear the index.
            </summary>
            <returns>This, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.BucketCount">
            <summary>
            Gets the number of buckets in the index. This will be the same as the number of labels, plus buckets for the underflow, overflow, and inflow(s).
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.RecordCount">
            <summary>
            Gets the number of records in the index: that is, the total number of distinct &lt;name,data&gt; pairs added with AddRecord(...), over all the buckets.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.GetEnumerator">
            <summary>
            Return an enumerator over the buckets.
            </summary>
            <returns>Enumerator over buckets.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.InitBuckets">
            <summary>
            Creates an index, and buckets and sorts the list of records into the index.
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.IsOneLabelBetterThanOther(ICU4N.Text.Normalizer2,System.String,System.String)">
            <summary>
            Returns true if one index character string is "better" than the other.
            Shorter NFKD is better, and otherwise NFKD-binary-less-than is
            better, and otherwise binary-less-than is better.
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.BucketList.GetFullEnumerator">
            <summary>
            Private enumerator over all the buckets, visible and invisible
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.BucketList.GetEnumerator">
            <summary>
            Enumerator over just the visible buckets.
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.GetFirstCharactersInScripts">
            <summary>
            Return a list of the first character in each script. Only exposed for testing.
            </summary>
            <returns>List of first characters in each script.</returns>
            <internal/>
        </member>
        <member name="T:ICU4N.Text.ImmutableIndex`1">
            <summary>
            Immutable, thread-safe version of <see cref="T:ICU4N.Text.AlphabeticIndex`1"/>.
            This class provides thread-safe methods for bucketing,
            and random access to buckets and their properties,
            but does not offer adding records to the index.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="P:ICU4N.Text.ImmutableIndex`1.BucketCount">
            <summary>
            Gets the number of index buckets and labels, including underflow/inflow/overflow.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Text.ImmutableIndex`1.GetBucketIndex(System.String)">
            <summary>
            Finds the index bucket for the given name and returns the number of that bucket.
            Use <see cref="M:ICU4N.Text.ImmutableIndex`1.GetBucket(System.Int32)"/> to get the bucket's properties.
            </summary>
            <param name="name">The string to be sorted into an index bucket.</param>
            <returns>The bucket number for the name.</returns>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Text.ImmutableIndex`1.GetBucket(System.Int32)">
            <summary>
            Returns the <paramref name="index"/>-th bucket. Returns null if the index is out of range.
            </summary>
            <param name="index">Bucket number.</param>
            <returns>The <paramref name="index"/>-th bucket.</returns>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Text.ImmutableIndex`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
            <stable>ICU 51</stable>
        </member>
        <member name="T:ICU4N.Text.Record`1">
            <summary>
            A (name, data) pair, to be sorted by name into one of the index buckets.
            The user data is not used by the index implementation.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.Record`1.Name">
            <summary>
            Gets the name.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.Record`1.Data">
            <summary>
            Gets the data.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.Record`1.ToString">
            <summary>
            Returns <c>name + "=" + data</c>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Text.Bucket`1">
            <summary>
            An index "bucket" with a label string and type.
            It is referenced by <see cref="M:ICU4N.Text.AlphabeticIndex`1.GetBucketIndex(System.String)"/>
            and <see cref="M:ICU4N.Text.ImmutableIndex`1.GetBucketIndex(System.String)"/>,
            returned by <see cref="M:ICU4N.Text.ImmutableIndex`1.GetBucket(System.Int32)"/>,
            and <see cref="M:ICU4N.Text.AlphabeticIndex`1.AddRecord(System.String,`0)"/> adds a record
            into a bucket according to the record's name.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.Bucket`1.#ctor(System.String,System.String,ICU4N.Text.BucketLabelType)">
            <summary>
            Set up the bucket.
            </summary>
            <param name="label">Label for the bucket.</param>
            <param name="lowerBoundary"></param>
            <param name="labelType">Is an underflow, overflow, or inflow bucket.</param>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.Bucket`1.Label">
            <summary>
            Gets the label for the bucket.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.Bucket`1.LabelType">
            <summary>
            Is a normal, underflow, overflow, or inflow bucket?
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.Bucket`1.Count">
            <summary>
            Gets the number of records in the bucket.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.Bucket`1.GetEnumerator">
            <summary>
            Enumerator over the records in the bucket.
            </summary>
            <returns>An enumerator over the records in the bucket.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.Bucket`1.ToString">
            <summary>
            Returns a name with the <see cref="F:ICU4N.Text.Bucket`1.labelType"/>, <see cref="F:ICU4N.Text.Bucket`1.lowerBoundary"/>, and <see cref="F:ICU4N.Text.Bucket`1.label"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Text.BucketLabelType">
            <summary>
            Type of the label
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.BucketLabelType.Normal">
            <summary>
            Normal
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.BucketLabelType.Underflow">
            <summary>
            Underflow (before the first)
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.BucketLabelType.Inflow">
            <summary>
            Inflow (between scripts)
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.BucketLabelType.Overflow">
            <summary>
            Overflow (after the last)
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Text.CollationElementIterator">
            <summary>
            <see cref="T:ICU4N.Text.CollationElementIterator"/> is an iterator created by
            a <see cref="T:ICU4N.Text.RuleBasedCollator"/> to walk through a string. The return result of
            each iteration is a 32-bit collation element (CE) that defines the
            ordering priority of the next character or sequence of characters
            in the source string.
            </summary>
            <remarks>
            For illustration, consider the following in Slovak and in traditional Spanish collation:
            <code>
            "ca" -&gt; the first collation element is CE('c') and the second
                    collation element is CE('a').
            "cha" -&gt; the first collation element is CE('ch') and the second
                    collation element is CE('a').
            </code>
            And in German phonebook collation,
            <code>
            Since the character '&#230;' is a composed character of 'a' and 'e', the
            iterator returns two collation elements for the single character '&#230;'
            
            "&#230;b" -&gt; the first collation element is collation_element('a'), the
                         second collation element is collation_element('e'), and the
                         third collation element is collation_element('b').
            </code>
            <para/>
            For collation ordering comparison, the collation element results
            can not be compared simply by using basic arithmetic operators,
            e.g. &lt;, == or &gt;, further processing has to be done. Details
            can be found in the ICU
            <a href="http://userguide.icu-project.org/collation/architecture">
            User Guide</a>. An example of using the <see cref="T:ICU4N.Text.CollationElementIterator"/>
            for collation ordering comparison is the class
            <see cref="T:ICU4N.Text.StringSearch"/>.
            <para/>
            To construct a CollationElementIterator object, users
            call the method <see cref="M:ICU4N.Text.RuleBasedCollator.GetCollationElementIterator(System.String)"/>
            that defines the desired sorting order.
            <example>
            <code>
            string testString = "This is a test";
            RuleBasedCollator rbc = new RuleBasedCollator("&amp;a&lt;b");
            CollationElementIterator iterator = rbc.GetCollationElementIterator(testString);
            int primaryOrder = iterator.Ignorable;
            while (primaryOrder != iterator.NullOrder)
            {
                int order = iterator.Next();
                if (order != iterator.Ignorable &amp;&amp; order != iterator.NullOrder)
                {
                    // order is valid, not ignorable and we have not passed the end
                    // of the iteration, we do something
                    primaryOrder = CollationElementIterator.PrimaryOrder(order);
                    Console.WriteLine($"Next primary order 0x{primaryOrder.ToString("X")}");
                }
            }
            </code>
            </example>
            <para/>
            The method <see cref="M:ICU4N.Text.CollationElementIterator.Next"/> returns the collation order of the next character based on
            the comparison level of the collator. The method <see cref="M:ICU4N.Text.CollationElementIterator.Previous"/> returns the
            collation order of the previous character based on the comparison level of
            the collator. The <see cref="T:ICU4N.Text.CollationElementIterator"/> moves only in one direction
            between calls to <see cref="M:ICU4N.Text.CollationElementIterator.Reset"/>, <see cref="M:ICU4N.Text.CollationElementIterator.SetOffset(System.Int32)"/> or <see cref="M:ICU4N.Text.CollationElementIterator.SetText(System.String)"/>. That is, <see cref="M:ICU4N.Text.CollationElementIterator.Next"/> and
            <see cref="M:ICU4N.Text.CollationElementIterator.Previous"/> can not be inter-used. Whenever <see cref="M:ICU4N.Text.CollationElementIterator.Previous"/> is to be called after
            <see cref="M:ICU4N.Text.CollationElementIterator.Next"/> or vice versa, <see cref="M:ICU4N.Text.CollationElementIterator.Reset"/>, <see cref="M:ICU4N.Text.CollationElementIterator.SetOffset(System.Int32)"/> or <see cref="M:ICU4N.Text.CollationElementIterator.SetText(System.String)"/> has to be called first
            to reset the status, shifting current position to either the end or the start of
            the string (<see cref="M:ICU4N.Text.CollationElementIterator.Reset"/> or <see cref="M:ICU4N.Text.CollationElementIterator.SetText(System.String)"/>), or the specified position (<see cref="M:ICU4N.Text.CollationElementIterator.SetOffset(System.Int32)"/>).
            Hence at the next call of <see cref="M:ICU4N.Text.CollationElementIterator.Next"/> or <see cref="M:ICU4N.Text.CollationElementIterator.Previous"/>, the first or last collation order,
            or collation order at the specified position will be returned. If a change of
            direction is done without one of these calls, the result is undefined.
            <para/>
            This class cannot be inherited.
            </remarks>
            <seealso cref="T:ICU4N.Text.Collator"/>
            <seealso cref="T:ICU4N.Text.RuleBasedCollator"/>
            <seealso cref="T:ICU4N.Text.StringSearch"/>
            <author>Syn Wee Quek</author>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.CollationElementIterator.dir_">
            <summary>
            &lt;0: backwards; 0: just after <see cref="M:ICU4N.Text.CollationElementIterator.Reset"/> (<see cref="M:ICU4N.Text.CollationElementIterator.Previous"/> begins from end);
            1: just after <see cref="M:ICU4N.Text.CollationElementIterator.SetOffset(System.Int32)"/>; >1: forward
            </summary>
        </member>
        <member name="F:ICU4N.Text.CollationElementIterator.offsets_">
            <summary>
            Stores offsets from expansions and from unsafe-backwards iteration,
            so that <see cref="M:ICU4N.Text.CollationElementIterator.GetOffset"/> returns intermediate offsets for the CEs
            that are consistent with forward iteration.
            </summary>
        </member>
        <member name="F:ICU4N.Text.CollationElementIterator.NullOrder">
            <summary>
            This constant is returned by the iterator in the methods
            <see cref="M:ICU4N.Text.CollationElementIterator.Next"/> and <see cref="M:ICU4N.Text.CollationElementIterator.Previous"/> when the end or the beginning of the
            source string has been reached, and there are no more valid
            collation elements to return.
            <para/>
            See <see cref="T:ICU4N.Text.CollationElementIterator"/> for an example of use.
            </summary>
            <stable>ICU 2.8</stable>
            <seealso cref="M:ICU4N.Text.CollationElementIterator.Next"/>
            <seealso cref="M:ICU4N.Text.CollationElementIterator.Previous"/>
        </member>
        <member name="F:ICU4N.Text.CollationElementIterator.Ignorable">
            <summary>
            This constant is returned by the iterator in the methods
            <see cref="M:ICU4N.Text.CollationElementIterator.Next"/> and <see cref="M:ICU4N.Text.CollationElementIterator.Previous"/> when a collation element result is to be
            ignored.
            <para/>
            See <see cref="T:ICU4N.Text.CollationElementIterator"/> for an example of use.
            </summary>
            <stable>ICU 2.8</stable>
            <seealso cref="M:ICU4N.Text.CollationElementIterator.Next"/>
            <seealso cref="M:ICU4N.Text.CollationElementIterator.Previous"/>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.PrimaryOrder(System.Int32)">
            <summary>
            Return the primary order of the specified collation element,
            i.e. the first 16 bits.  This value is unsigned.
            </summary>
            <param name="ce">The collation element.</param>
            <returns>The element's 16 bits primary order.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.SecondaryOrder(System.Int32)">
            <summary>
            Return the secondary order of the specified collation element,
            i.e. the 16th to 23th bits, inclusive.  This value is unsigned.
            </summary>
            <param name="ce">The collation element.</param>
            <returns>The element's 8 bits secondary order.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.TertiaryOrder(System.Int32)">
            <summary>
            Return the tertiary order of the specified collation element, i.e. the last
            8 bits.  This value is unsigned.
            </summary>
            <param name="ce">The collation element.</param>
            <returns>The element's 8 bits tertiary order.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.#ctor(System.String,ICU4N.Text.RuleBasedCollator)">
            <summary>
            <see cref="T:ICU4N.Text.CollationElementIterator"/> constructor. This takes a source
            string and a <see cref="T:ICU4N.Text.RuleBasedCollator"/>. The iterator will walk through
            the source string based on the rules defined by the
            collator. If the source string is empty, <see cref="F:ICU4N.Text.CollationElementIterator.NullOrder"/> will be
            returned on the first call to <see cref="M:ICU4N.Text.CollationElementIterator.Next"/>.
            </summary>
            <param name="source">The source string.</param>
            <param name="collator">The <see cref="T:ICU4N.Text.RuleBasedCollator"/>.</param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.#ctor(ICU4N.Support.Text.CharacterIterator,ICU4N.Text.RuleBasedCollator)">
            <summary>
            <see cref="T:ICU4N.Text.CollationElementIterator"/> constructor. This takes a source
            character iterator and a <see cref="T:ICU4N.Text.RuleBasedCollator"/>. The iterator will
            walk through the source string based on the rules defined by
            the collator. If the source string is empty, <see cref="F:ICU4N.Text.CollationElementIterator.NullOrder"/> will be
            returned on the first call to <see cref="M:ICU4N.Text.CollationElementIterator.Next"/>.
            </summary>
            <param name="source">The source string iterator.</param>
            <param name="collator">The <see cref="T:ICU4N.Text.RuleBasedCollator"/>.</param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.#ctor(ICU4N.Text.UCharacterIterator,ICU4N.Text.RuleBasedCollator)">
            <summary>
            <see cref="T:ICU4N.Text.CollationElementIterator"/> constructor. This takes a source
            character iterator and a <see cref="T:ICU4N.Text.RuleBasedCollator"/>. The iterator will
            walk through the source string based on the rules defined by
            the collator. If the source string is empty, <see cref="F:ICU4N.Text.CollationElementIterator.NullOrder"/> will be
            returned on the first call to <see cref="M:ICU4N.Text.CollationElementIterator.Next"/>.
            </summary>
            <param name="source">The source string iterator.</param>
            <param name="collator">The <see cref="T:ICU4N.Text.RuleBasedCollator"/>.</param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.GetOffset">
            <summary>
            Returns the character offset in the source string
            corresponding to the next collation element. I.e., <see cref="M:ICU4N.Text.CollationElementIterator.GetOffset"/>
            returns the position in the source string corresponding to the
            collation element that will be returned by the next call to
            <see cref="M:ICU4N.Text.CollationElementIterator.Next"/> or <see cref="M:ICU4N.Text.CollationElementIterator.Previous"/>. This value could be any of:
            <list type="bullet">
                <item>
                    <description>
                        The index of the <b>first</b> character corresponding to
                        the next collation element. (This means that if
                        <see cref="M:ICU4N.Text.CollationElementIterator.SetOffset(System.Int32)"/> sets the index in the middle of
                        a contraction, <see cref="M:ICU4N.Text.CollationElementIterator.GetOffset"/> returns the index of
                        the first character in the contraction, which may not be equal
                        to the original offset that was set. Hence calling <see cref="M:ICU4N.Text.CollationElementIterator.GetOffset"/>
                        immediately after <see cref="M:ICU4N.Text.CollationElementIterator.SetOffset(System.Int32)"/> does not guarantee that the
                        original offset set will be returned.)
                    </description>
                </item>
                <item>
                    <description>
                        If normalization is on, the index of the <b>immediate</b>
                        subsequent character, or composite character with the first
                        character, having a combining class of 0.
                    </description>
                </item>
                <item>
                    <description>
                        The length of the source string, if iteration has reached
                        the end.
                    </description>
                </item>
            </list>
            </summary>
            <returns>
            The character offset in the source string corresponding to the
            collation element that will be returned by the next call to
            <see cref="M:ICU4N.Text.CollationElementIterator.Next"/> or <see cref="M:ICU4N.Text.CollationElementIterator.Previous"/>.
            </returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.Next">
            <summary>
            Get the next collation element in the source string.
            <para/>
            This iterator iterates over a sequence of collation elements
            that were built from the string. Because there isn't
            necessarily a one-to-one mapping from characters to collation
            elements, this doesn't mean the same thing as "return the
            collation element [or ordering priority] of the next character
            in the string".
            <para/>
            This function returns the collation element that the
            iterator is currently pointing to, and then updates the
            internal pointer to point to the next element.
            </summary>
            <returns>The next collation element or <see cref="F:ICU4N.Text.CollationElementIterator.NullOrder"/> if the end of the iteration has been reached.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.Previous">
            <summary>
            Get the previous collation element in the source string.
            <para/>
            This iterator iterates over a sequence of collation elements
            that were built from the string. Because there isn't
            necessarily a one-to-one mapping from characters to collation
            elements, this doesn't mean the same thing as "return the
            collation element [or ordering priority] of the previous
            character in the string".
            <para/>
            This function updates the iterator's internal pointer to
            point to the collation element preceding the one it's currently
            pointing to and then returns that element, while <see cref="M:ICU4N.Text.CollationElementIterator.Next"/> returns
            the current element and then updates the pointer.
            </summary>
            <returns>The previous collation element, or <see cref="F:ICU4N.Text.CollationElementIterator.NullOrder"/> when the start of
            the iteration has been reached.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.Reset">
            <summary>
            Resets the cursor to the beginning of the string. The next
            call to <see cref="M:ICU4N.Text.CollationElementIterator.Next"/> or <see cref="M:ICU4N.Text.CollationElementIterator.Previous"/> will return the first and last
            collation element in the string, respectively.
            <para/>
            If the <see cref="T:ICU4N.Text.RuleBasedCollator"/> used by this iterator has had its
            attributes changed, calling <see cref="M:ICU4N.Text.CollationElementIterator.Reset"/> will reinitialize the
            iterator to use the new attributes.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.SetOffset(System.Int32)">
            <summary>
            Sets the iterator to point to the collation element
            corresponding to the character at the specified offset. The
            value returned by the next call to <see cref="M:ICU4N.Text.CollationElementIterator.Next"/> will be the collation
            element corresponding to the characters at <paramref name="newOffset"/>.
            <para/>
            If <paramref name="newOffset"/> is in the middle of a contracting character
            sequence, the iterator is adjusted to the start of the
            contracting sequence. This means that <see cref="M:ICU4N.Text.CollationElementIterator.GetOffset"/> is not
            guaranteed to return the same value set by this method.
            <para/>
            If the decomposition mode is on, and offset is in the middle
            of a decomposible range of source text, the iterator may not
            return a correct result for the next forwards or backwards
            iteration.  The user must ensure that the offset is not in the
            middle of a decomposible range.
            </summary>
            <param name="newOffset">The character offset into the original source string to
            set. Note that this is not an offset into the corresponding
            sequence of collation elements.</param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.SetText(System.String)">
            <summary>
            Set a new source string for iteration, and reset the offset
            to the beginning of the text.
            </summary>
            <param name="source">The new source string for iteration.</param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.SetText(ICU4N.Text.UCharacterIterator)">
            <summary>
            Set a new source string iterator for iteration, and reset the
            offset to the beginning of the text.
            <para/>
            The source iterator's integrity will be preserved since a new copy
            will be created for use.
            </summary>
            <param name="source">The new source string iterator for iteration.</param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.SetText(ICU4N.Support.Text.CharacterIterator)">
            <summary>
            Set a new source string iterator for iteration, and reset the
            offset to the beginning of the text.
            </summary>
            <param name="source">The new source string iterator for iteration.</param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.GetMaxExpansion(System.Int32)">
            <summary>
            Returns the maximum length of any expansion sequence that ends with
            the specified collation element. If there is no expansion with this
            collation element as the last element, returns 1.
            </summary>
            <param name="ce">A collation element returned by <see cref="M:ICU4N.Text.CollationElementIterator.Previous"/> or <see cref="M:ICU4N.Text.CollationElementIterator.Next"/>.</param>
            <returns>The maximum length of any expansion sequence ending with the specified collation element.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="P:ICU4N.Text.CollationElementIterator.NormalizeDir">
            <summary>
            Normalizes dir_=1 (just after <see cref="M:ICU4N.Text.CollationElementIterator.SetOffset(System.Int32)"/>) to dir_=0 (just after <see cref="M:ICU4N.Text.CollationElementIterator.Reset"/>).
            </summary>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.Equals(System.Object)">
            <summary>
            Tests that argument object is equals to this <see cref="T:ICU4N.Text.CollationElementIterator"/>.
            Iterators are equal if the objects uses the same <see cref="T:ICU4N.Text.RuleBasedCollator"/>,
            the same source text and have the same current position in iteration.
            </summary>
            <param name="that">Object to test if it is equals to this <see cref="T:ICU4N.Text.CollationElementIterator"/>.</param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.GetHashCode">
            <summary>
            Gets a hash code representing the current <see cref="T:ICU4N.Text.CollationElementIterator"/>.
            </summary>
            <internal/>
        </member>
        <member name="P:ICU4N.Text.CollationElementIterator.RuleBasedCollator">
            <internal/>
        </member>
        <member name="T:ICU4N.Text.CollationKeyBoundMode">
            <summary>
            Options that used in the API <see cref="M:ICU4N.Text.CollationKey.GetBound(ICU4N.Text.CollationKeyBoundMode,ICU4N.Text.CollationStrength)"/> for getting a
            <see cref="T:ICU4N.Text.CollationKey"/> based on the bound mode requested.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Text.CollationKeyBoundMode.Lower">
            <summary>
            Lower bound
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Text.CollationKeyBoundMode.Upper">
            <summary>
            Upper bound that will match strings of exact size.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Text.CollationKeyBoundMode.UpperLong">
            <summary>
            Upper bound that will match all the strings that have the same
            initial substring as the given string.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="T:ICU4N.Text.CollationKey">
            <summary>
            A <see cref="T:ICU4N.Text.CollationKey"/> represents a <see cref="T:System.String"/>
            under the rules of a specific <see cref="T:ICU4N.Text.Collator"/> object.
            Comparing two <see cref="T:ICU4N.Text.CollationKey"/>s returns the
            relative order of the <see cref="T:System.String"/>s they represent.
            </summary>
            <remarks>
            Since the rule set of <see cref="T:ICU4N.Text.Collator"/>s can differ, the
            sort orders of the same string under two different
            <see cref="T:ICU4N.Text.Collator"/>s might differ.  Hence comparing
            <see cref="T:ICU4N.Text.CollationKey"/>s generated from different
            <see cref="T:ICU4N.Text.Collator"/>s can give incorrect results.
            <para/>
            Both the method
            <see cref="M:ICU4N.Text.CollationKey.CompareTo(ICU4N.Text.CollationKey)"/> and the method
            <see cref="M:ICU4N.Text.Collator.Compare(System.String,System.String)"/> compare two strings
            and returns their relative order.  The performance characteristics
            of these two approaches can differ.
            Note that collation keys are often less efficient than simply doing comparison.
            For more details, see the ICU User Guide.
            <para/>
            During the construction of a <see cref="T:ICU4N.Text.CollationKey"/>, the
            entire source string is examined and processed into a series of
            bits terminated by a null, that are stored in the <see cref="T:ICU4N.Text.CollationKey"/>.
            When <see cref="M:ICU4N.Text.CollationKey.CompareTo(ICU4N.Text.CollationKey)"/> executes, it
            performs bitwise comparison on the bit sequences.  This can incur
            startup cost when creating the <see cref="T:ICU4N.Text.CollationKey"/>, but once
            the key is created, binary comparisons are fast.  This approach is
            recommended when the same strings are to be compared over and over
            again.
            <para/>
            On the other hand, implementations of
            <see cref="M:ICU4N.Text.Collator.Compare(System.String,System.String)"/> can examine and
            process the strings only until the first characters differing in
            order.  This approach is recommended if the strings are to be
            compared only once.
            <para/>
            More information about the composition of the bit sequence can
            be found in the
            <a href="http://www.icu-project.org/userguide/Collate_ServiceArchitecture.html">
            user guide</a>.
            <para/>
            The following example shows how <see cref="T:ICU4N.Text.CollationKey"/>s can be used
            to sort a list of <see cref="T:System.String"/>s.
            
            <code>
            // Create an array of CollationKeys for the Strings to be sorted.
            Collator myCollator = Collator.GetInstance();
            CollationKey[] keys = new CollationKey[3];
            keys[0] = myCollator.GetCollationKey("Tom");
            keys[1] = myCollator.GetCollationKey("Dick");
            keys[2] = myCollator.GetCollationKey("Harry");
            Sort( keys );
            
            //...
            
            // Inside body of sort routine, compare keys this way
            if( keys[i].CompareTo( keys[j] ) &gt; 0 )
                // swap keys[i] and keys[j]
                
            //...
            
            // Finally, when we've returned from sort.
            Console.WriteLine(keys[0].SourceString);
            Console.WriteLine(keys[1].SourceString);
            Console.WriteLine(keys[2].SourceString);
            </code>
            <para/>
            This class is not subclassable
            </remarks>
            <seealso cref="T:ICU4N.Text.Collator"/>
            <seealso cref="T:ICU4N.Text.RuleBasedCollator"/>
            <author>Syn Wee Quek</author>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.#ctor(System.String,System.Byte[])">
            <summary>
            <see cref="T:ICU4N.Text.CollationKey"/> constructor.
            This constructor is given public access, unlike the <c>System.Globalization.SortKey</c>, to
            allow access to users extending the <see cref="T:ICU4N.Text.Collator"/> class. See
            <see cref="M:ICU4N.Text.Collator.GetCollationKey(System.String)"/>.
            </summary>
            <param name="source">String this <see cref="T:ICU4N.Text.CollationKey"/> is to represent.</param>
            <param name="key">Array of bytes that represent the collation order of argument
            source terminated by a null.</param>
            <seealso cref="T:ICU4N.Text.Collator"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.#ctor(System.String,System.Byte[],System.Int32)">
            <summary>
            Private constructor, takes a <paramref name="length"/> argument so it need not be lazy-evaluated.
            There must be a 00 byte at <paramref name="key"/>[<paramref name="length"/>] and none before.
            </summary>
        </member>
        <member name="M:ICU4N.Text.CollationKey.#ctor(System.String,ICU4N.Text.RawCollationKey)">
            <summary>
            <see cref="T:ICU4N.Text.CollationKey"/> constructor that forces key to release its internal byte
            array for adoption. key will have a null byte array after this
            construction.
            </summary>
            <param name="source">String this <see cref="T:ICU4N.Text.CollationKey"/> is to represent.</param>
            <param name="key"><see cref="T:ICU4N.Text.RawCollationKey"/> object that represents the collation order of
            argument source.</param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="P:ICU4N.Text.CollationKey.SourceString">
            <summary>
            Gets the source string that this <see cref="T:ICU4N.Text.CollationKey"/> represents.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.ToByteArray">
            <summary>
            Duplicates and returns the value of this <see cref="T:ICU4N.Text.CollationKey"/> as a sequence
            of big-endian bytes terminated by a null.
            </summary>
            <remarks>
            If two <see cref="T:ICU4N.Text.CollationKey"/>s can be legitimately compared, then one can
            compare the byte arrays of each to obtain the same result, e.g.
            <code>
            byte key1[] = collationkey1.ToByteArray();
            byte key2[] = collationkey2.ToByteArray();
            int key, targetkey;
            int i = 0;
            do
            {
                key = key1[i] &amp; 0xFF;
                targetkey = key2[i] &amp; 0xFF;
                if (key &lt; targetkey)
                {
                    Console.WriteLine("String 1 is less than string 2");
                    return;
                }
                if (targetkey &lt; key)
                {
                    Console.WriteLine("String 1 is more than string 2");
                }
                i++;
            } while (key != 0 &amp;&amp; targetKey != 0);
            
            Console.WriteLine("Strings are equal.");
            </code>
            </remarks>
            <returns>
            <see cref="T:ICU4N.Text.CollationKey"/> value in a sequence of big-endian byte bytes
            terminated by a null.
            </returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.CompareTo(ICU4N.Text.CollationKey)">
            <summary>
            Compare this <see cref="T:ICU4N.Text.CollationKey"/> to another <see cref="T:ICU4N.Text.CollationKey"/>.  The
            collation rules of the <see cref="T:ICU4N.Text.Collator"/> that created this key are
            applied.
            </summary>
            <remarks>
            <strong>Note:</strong> Comparison between <see cref="T:ICU4N.Text.CollationKey"/>s
            created by different <see cref="T:ICU4N.Text.Collator"/>s might return incorrect
            results.  See class documentation.
            </remarks>
            <param name="target">Target <see cref="T:ICU4N.Text.CollationKey"/>.</param>
            <returns>
            An integer value.  If the value is less than zero this CollationKey
            is less than than target, if the value is zero they are equal, and
            if the value is greater than zero this <see cref="T:ICU4N.Text.CollationKey"/> is greater
            than target.
            </returns>
            <exception cref="T:System.ArgumentNullException">is thrown if argument is null.</exception>
            <seealso cref="M:ICU4N.Text.Collator.Compare(System.String,System.String)"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.CompareTo(System.Object)">
            <summary>
            Compare this <see cref="T:ICU4N.Text.CollationKey"/> to another <see cref="T:ICU4N.Text.CollationKey"/>.  The
            collation rules of the <see cref="T:ICU4N.Text.Collator"/> that created this key are
            applied.
            </summary>
            <remarks>
            <strong>Note:</strong> Comparison between <see cref="T:ICU4N.Text.CollationKey"/>s
            created by different <see cref="T:ICU4N.Text.Collator"/>s might return incorrect
            results.  See class documentation.
            </remarks>
            <param name="other">Target <see cref="T:ICU4N.Text.CollationKey"/>.</param>
            <returns>
            An integer value.  If the value is less than zero this CollationKey
            is less than than target, if the value is zero they are equal, and
            if the value is greater than zero this <see cref="T:ICU4N.Text.CollationKey"/> is greater
            than target.
            </returns>
            <exception cref="T:System.ArgumentNullException">is thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">If <paramref name="other"/> cannot be cast to <see cref="T:ICU4N.Text.CollationKey"/>.</exception>
            <seealso cref="M:ICU4N.Text.Collator.Compare(System.String,System.String)"/>
            <stable>ICU4N 60.1</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.Equals(System.Object)">
            <summary>
            Compare this <see cref="T:ICU4N.Text.CollationKey"/> and the specified <see cref="T:System.Object"/> for
            equality.  The collation rules of the <see cref="T:ICU4N.Text.Collator"/> that created
            this key are applied.
            <para/>
            See note in <see cref="M:ICU4N.Text.CollationKey.CompareTo(ICU4N.Text.CollationKey)"/> for warnings about
            possible incorrect results.
            </summary>
            <param name="target">The object to compare to.</param>
            <returns>true if the two keys compare as equal, false otherwise.</returns>
            <seealso cref="M:ICU4N.Text.CollationKey.CompareTo(ICU4N.Text.CollationKey)"/>
            <seealso cref="M:ICU4N.Text.CollationKey.CompareTo(System.Object)"/>
        </member>
        <member name="M:ICU4N.Text.CollationKey.Equals(ICU4N.Text.CollationKey)">
            <summary>
            Compare this <see cref="T:ICU4N.Text.CollationKey"/> and the argument target <see cref="T:ICU4N.Text.CollationKey"/> for
            equality.
            The collation
            rules of the <see cref="T:ICU4N.Text.Collator"/> object which created these objects are applied.
            <para/>
            See note in <see cref="M:ICU4N.Text.CollationKey.CompareTo(ICU4N.Text.CollationKey)"/> for warnings of incorrect results
            </summary>
            <param name="target">The <see cref="T:ICU4N.Text.CollationKey"/> to compare to.</param>
            <returns>true if two objects are equal, false otherwise.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.GetHashCode">
            <summary>
            Returns a hash code for this CollationKey. The hash value is calculated
            on the key itself, not the string from which the key was created. Thus
            if x and y are <see cref="T:ICU4N.Text.CollationKey"/>s, then x.GetHashCode(x) == y.GetHashCode()
            if x.Equals(y) is true. This allows language-sensitive comparison in a
            <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>The hash value.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.GetBound(ICU4N.Text.CollationKeyBoundMode,ICU4N.Text.CollationStrength)">
            <summary>
            Produces a bound for the sort order of a given collation key and a
            strength level. This API does not attempt to find a bound for the
            <see cref="T:ICU4N.Text.CollationKey"/> string representation, hence null will be returned in its
            place.
            </summary>
            <remarks>
            Resulting bounds can be used to produce a range of strings that are
            between upper and lower bounds. For example, if bounds are produced
            for a sortkey of string "smith", strings between upper and lower
            bounds with primary strength would include "Smith", "SMITH", "sMiTh".
            <para/>
            There are two upper bounds that can be produced. If <see cref="F:ICU4N.Text.CollationKeyBoundMode.Upper"/>
            is produced, strings matched would be as above. However, if a bound
            is produced using <see cref="F:ICU4N.Text.CollationKeyBoundMode.UpperLong"/> is used, the above example will
            also match "Smithsonian" and similar.
            <para/>
            For more on usage, see example in test procedure
            <a href="http://source.icu-project.org/repos/icu/icu4j/trunk/src/com/ibm/icu/dev/test/collator/CollationAPITest.java">
            src/com/ibm/icu/dev/test/collator/CollationAPITest/TestBounds.
            </a>
            <para/>
            Collation keys produced may be compared using the <see cref="M:ICU4N.Text.CollationKey.CompareTo(ICU4N.Text.CollationKey)"/> API.
            </remarks>
            <param name="boundType">
            Mode of bound required. It can be <see cref="F:ICU4N.Text.CollationKeyBoundMode.Lower"/>, which
            produces a lower inclusive bound, <see cref="F:ICU4N.Text.CollationKeyBoundMode.Upper"/>, that
            produces upper bound that matches strings of the same
            length or <see cref="F:ICU4N.Text.CollationKeyBoundMode.UpperLong"/> that matches strings that
            have the same starting substring as the source string.
            </param>
            <param name="noOfLevels">
            Strength levels required in the resulting bound
            (for most uses, the recommended value is <see cref="F:ICU4N.Text.CollationStrength.Primary"/>). This
            strength should be less than the maximum strength of
            this <see cref="T:ICU4N.Text.CollationKey"/>.
            See users guide for explanation on the strength levels a
            collation key can have.
            </param>
            <returns>
            The result bounded <see cref="T:ICU4N.Text.CollationKey"/> with a valid sort order but
            a null string representation.
            </returns>
            <exception cref="T:System.ArgumentException">
            thrown when the strength level
            requested is higher than or equal to the strength in this
            <see cref="T:ICU4N.Text.CollationKey"/>.
            In the case of an Exception, information
            about the maximum strength to use will be returned in the
            Exception. The user can then call <see cref="M:ICU4N.Text.CollationKey.GetBound(ICU4N.Text.CollationKeyBoundMode,ICU4N.Text.CollationStrength)"/> again with the
            appropriate strength.
            </exception>
            <seealso cref="T:ICU4N.Text.CollationKey"/>
            <seealso cref="T:ICU4N.Text.CollationKeyBoundMode"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Primary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Secondary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Tertiary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Quaternary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Identical"/>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.Merge(ICU4N.Text.CollationKey)">
            <summary>
            Merges this <see cref="T:ICU4N.Text.CollationKey"/> with another.
            The levels are merged with their corresponding counterparts
            (primaries with primaries, secondaries with secondaries etc.).
            Between the values from the same level a separator is inserted.
            </summary>
            <remarks>
            This is useful, for example, for combining sort keys from first and last names
            to sort such pairs.
            See <a href="http://www.unicode.org/reports/tr10/#Merging_Sort_Keys">http://www.unicode.org/reports/tr10/#Merging_Sort_Keys</a>.
            <para/>
            The recommended way to achieve "merged" sorting is by
            concatenating strings with U+FFFE between them.
            The concatenation has the same sort order as the merged sort keys,
            but Merge(GetCollationKey(str1), GetCollationKey(str2)) may differ from GetCollationKey(str1 + '\uFFFE' + str2).
            Using strings with U+FFFE may yield shorter sort keys.
            <para/>
            For details about Sort Key Features see
            <a href="http://userguide.icu-project.org/collation/api#TOC-Sort-Key-Features">http://userguide.icu-project.org/collation/api#TOC-Sort-Key-Features</a>.
            <para/>
            It is possible to merge multiple sort keys by consecutively merging
            another one with the intermediate result.
            <para/>
            Only the sort key bytes of the <see cref="T:ICU4N.Text.CollationKey"/>s are merged.
            This API does not attempt to merge the
            string representations of the <see cref="T:ICU4N.Text.CollationKey"/>s, hence null will be returned
            as the result's string representation.
            <para/>
            Example (uncompressed):
            <code>
            191B1D 01 050505 01 910505 00
            1F2123 01 050505 01 910505 00
            </code>
            will be merged as
            <code>
            191B1D 02 1F2123 01 050505 02 050505 01 910505 02 910505 00
            </code>
            </remarks>
            <param name="source"><see cref="T:ICU4N.Text.CollationKey"/> to merge with.</param>
            <returns>A <see cref="T:ICU4N.Text.CollationKey"/> that contains the valid merged sort keys
            with a null String representation,
            i.e. <c>new CollationKey(null, merged_sort_keys)</c>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if source <see cref="T:ICU4N.Text.CollationKey"/>
            argument is null or of 0 length.</exception>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Text.CollationKey.m_key_">
            <summary>
            Sequence of bytes that represents the sort key
            </summary>
        </member>
        <member name="F:ICU4N.Text.CollationKey.m_source_">
            <summary>
            Source string this <see cref="T:ICU4N.Text.CollationKey"/> represents
            </summary>
        </member>
        <member name="F:ICU4N.Text.CollationKey.m_hashCode_">
            <summary>
            Hash code for the key
            </summary>
        </member>
        <member name="F:ICU4N.Text.CollationKey.m_length_">
            <summary>
            Gets the length of this <see cref="T:ICU4N.Text.CollationKey"/>
            </summary>
        </member>
        <member name="F:ICU4N.Text.CollationKey.MERGE_SEPERATOR_">
            <summary>
            Collation key merge seperator
            </summary>
        </member>
        <member name="M:ICU4N.Text.CollationKey.GetLength">
            <summary>
            Gets the length of the <see cref="T:ICU4N.Text.CollationKey"/>.
            </summary>
            <returns>Length of the <see cref="T:ICU4N.Text.CollationKey"/>.</returns>
        </member>
        <member name="T:ICU4N.Text.CollationStrength">
            <summary>
            Use this to set the strength of a <see cref="T:ICU4N.Text.Collator"/> object.
            This is also used to determine the strength of sort keys
            generated from <see cref="T:ICU4N.Text.Collator"/> objects
            The usual strength for most locales (except Japanese) is tertiary.
            Quaternary strength is useful when combined with shifted setting
            for alternate handling attribute and for JIS x 4061 collation,
            when it is used to distinguish between Katakana and Hiragana
            (this is achieved by setting the <see cref="P:ICU4N.Text.RuleBasedCollator.IsHiraganaQuaternary"/> to true.
            Otherwise, quaternary level is affected only by the number of
            non ignorable code points in the string.
            </summary>
        </member>
        <member name="F:ICU4N.Text.CollationStrength.Primary">
            <summary>
            Strongest collator strength value. Typically used to denote differences
            between base characters. See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Base letter represents a primary difference.  Set comparison
            level to Primary to ignore secondary and tertiary differences.
            Example of primary difference, "abc" &lt; "abd"
            </summary>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.CollationStrength.Secondary">
            <summary>
            Second level collator strength value.
            Accents in the characters are considered secondary differences.
            Other differences between letters can also be considered secondary
            differences, depending on the language.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Diacritical differences on the same base letter represent a secondary
            difference.  Set comparison level to Secondary to ignore tertiary
            differences.
            Example of secondary difference, "a&#x308;" >> "a".
            </summary>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.CollationStrength.Tertiary">
            <summary>
            Third level collator strength value.
            Upper and lower case differences in characters are distinguished at this
            strength level. In addition, a variant of a letter differs from the base
            form on the tertiary level.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Set comparison level to Tertiary to include
            all comparison differences.
            Example of tertiary difference, "abc" &lt;&lt;&lt; "ABC".
            </summary>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.CollationStrength.Quaternary">
            <summary>
            <icu/>Fourth level collator strength value.
            When punctuation is ignored
            (see <a href="http://userguide.icu-project.org/collation/concepts#TOC-Ignoring-Punctuation">Ignoring Punctuation in the User Guide</a>) 
            at <see cref="F:ICU4N.Text.CollationStrength.Primary"/> to <see cref="F:ICU4N.Text.CollationStrength.Tertiary"/>
            strength, an additional strength level can
            be used to distinguish words with and without punctuation.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Quaternary level is usually only affected by the number of
            non-ignorable code points in the string.
            </summary>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.CollationStrength.Identical">
            <summary>
            Smallest <see cref="T:ICU4N.Text.Collator"/> strength value. When all other strengths are equal,
            the IDENTICAL strength is used as a tiebreaker. The Unicode code point
            values of the NFD form of each string are compared, just in case there
            is no difference.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Note this value is different from JDK's
            <para/>
            Two characters are considered "identical" when they have the same
            unicode spellings.
            For example, "a&#x308;" == "a&#x308;".
            </summary>
            <remarks>Identical strength is rarely useful, as it amounts to
            codepoints of the NFD form of the string</remarks>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.NormalizationMode.NoDecomposition">
            <summary>
            Decomposition mode value. With <see cref="F:ICU4N.Text.NormalizationMode.NoDecomposition"/> set, Strings
            will not be decomposed for collation. This is the default
            decomposition setting unless otherwise specified by the locale
            used to create the <see cref="T:ICU4N.Text.Collator"/>.
            <para/>
            <strong>Note</strong> this value is different from the JDK's.
            </summary>
            <seealso cref="F:ICU4N.Text.NormalizationMode.CanonicalDecomposition"/>
            <seealso cref="P:ICU4N.Text.Collator.Decomposition"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.NormalizationMode.CanonicalDecomposition">
            <summary>
            Decomposition mode value. With <see cref="F:ICU4N.Text.NormalizationMode.CanonicalDecomposition"/> set,
            characters that are canonical variants according to the Unicode standard
            will be decomposed for collation.
            <para/>
            <see cref="F:ICU4N.Text.NormalizationMode.CanonicalDecomposition"/> corresponds to Normalization Form D as
            described in <a href="http://www.unicode.org/unicode/reports/tr15/">Unicode Technical Report #15</a>.
            </summary>
            <seealso cref="F:ICU4N.Text.NormalizationMode.NoDecomposition"/>
            <seealso cref="P:ICU4N.Text.Collator.Decomposition"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="T:ICU4N.Text.ReorderCodes">
            <summary>
             Reordering codes for non-script groups that can be reordered under collation.
            </summary>
            <see cref="M:ICU4N.Text.Collator.GetReorderCodes"/>
            <see cref="M:ICU4N.Text.Collator.SetReorderCodes(System.Int32[])"/>
            <see cref="M:ICU4N.Text.Collator.GetEquivalentReorderCodes(System.Int32)"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.Default">
            <summary>
            A special reordering code that is used to specify the default reordering codes for a locale.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.None">
            <summary>
            A special reordering code that is used to specify no reordering codes.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.Others">
            <summary>
            A special reordering code that is used to specify all other codes used for reordering except
            for the codes listed as ReorderingCodes and those listed explicitly in a reordering.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.Space">
            <summary>
            Characters with the space property.
            This is equivalent to the rule value "space".
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.First">
            <summary>
            The first entry in the enumeration of reordering groups. This is intended for use in
            range checking and enumeration of the reorder codes.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.Punctuation">
            <summary>
            Characters with the punctuation property.
            This is equivalent to the rule value "punct".
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.Symbol">
            <summary>
            Characters with the symbol property.
            This is equivalent to the rule value "symbol".
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.Currency">
            <summary>
            Characters with the currency property.
            This is equivalent to the rule value "currency".
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.Digit">
            <summary>
            Characters with the digit property.
            This is equivalent to the rule value "digit".
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.Limit">
            <summary>
            One more than the highest normal <see cref="T:ICU4N.Text.ReorderCodes"/> value.
            </summary>
        </member>
        <member name="T:ICU4N.Text.CollatorFactory">
            <summary>
            A factory used with <see cref="M:ICU4N.Text.Collator.RegisterFactory(ICU4N.Text.CollatorFactory)"/> to register multiple collators and provide
            display names for them.  If standard locale display names are sufficient,
            Collator instances may be registered instead.
            <para/>
            <b>Note:</b> as of ICU4N 3.2, the default API for <see cref="T:ICU4N.Text.CollatorFactory"/> uses
            <see cref="T:ICU4N.Globalization.UCultureInfo"/> instead of <see cref="T:System.Globalization.CultureInfo"/>.  Instead of overriding <see cref="M:ICU4N.Text.CollatorFactory.CreateCollator(System.Globalization.CultureInfo)"/>,
            new implementations should override <see cref="M:ICU4N.Text.CollatorFactory.CreateCollator(ICU4N.Globalization.UCultureInfo)"/>. Note that
            one of these two methods <b>MUST</b> be overridden or else an infinite
            loop will occur.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="P:ICU4N.Text.CollatorFactory.Visible">
            <summary>
            Return true if this factory will be visible.  Default is true.
            If not visible, the locales supported by this factory will not
            be listed by <see cref="M:ICU4N.Text.Collator.GetCultures(ICU4N.Globalization.UCultureTypes)"/>.
            <para/>
            true if this factory is visible.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.CollatorFactory.CreateCollator(ICU4N.Globalization.UCultureInfo)">
            <summary>
            Return an instance of the appropriate collator.  If the locale
            is not supported, return null.
            <para/>
            <b>Note:</b> as of ICU4N 3.2, implementations should override
            this method instead of <see cref="M:ICU4N.Text.CollatorFactory.CreateCollator(System.Globalization.CultureInfo)"/>.
            </summary>
            <param name="loc">the locale for which this collator is to be created.</param>
            <returns>the newly created collator.</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.CollatorFactory.CreateCollator(System.Globalization.CultureInfo)">
            <summary>
            Return an instance of the appropriate collator.  If the locale
            is not supported, return null.
            <para/>
            <b>Note:</b> as of ICU4J 3.2, implementations should override
            <see cref="M:ICU4N.Text.CollatorFactory.CreateCollator(ICU4N.Globalization.UCultureInfo)"/> instead of this method, and inherit this
            method's implementation.  This method is no longer abstract
            and instead delegates to <see cref="M:ICU4N.Text.CollatorFactory.CreateCollator(ICU4N.Globalization.UCultureInfo)"/>.
            </summary>
            <param name="loc">the locale for which this collator is to be created.</param>
            <returns>the newly created collator.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.CollatorFactory.GetDisplayName(System.Globalization.CultureInfo,System.Globalization.CultureInfo)">
            <summary>
            Return the name of the collator for the <paramref name="objectLocale"/>, localized for the <paramref name="displayLocale"/>.
            If <paramref name="objectLocale"/> is not visible or not defined by the factory, return null.
            </summary>
            <param name="objectLocale">the locale identifying the collator</param>
            <param name="displayLocale">the locale for which the display name of the collator should be localized</param>
            <returns>the display name</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.CollatorFactory.GetDisplayName(ICU4N.Globalization.UCultureInfo,ICU4N.Globalization.UCultureInfo)">
            <summary>
            Return the name of the collator for the <paramref name="objectLocale"/>, localized for the <paramref name="displayLocale"/>.
            If <paramref name="objectLocale"/> is not visible or not defined by the factory, return null.
            </summary>
            <param name="objectLocale">the locale identifying the collator</param>
            <param name="displayLocale">the locale for which the display name of the collator should be localized</param>
            <returns>the display name</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.CollatorFactory.GetSupportedLocaleIDs">
            <summary>
            Return an unmodifiable collection of the locale names directly
            supported by this factory.
            </summary>
            <returns>the set of supported locale IDs.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.CollatorFactory.#ctor">
            <summary>
            Empty default constructor.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="T:ICU4N.Text.Collator">
            <summary>
            Collator performs locale-sensitive string comparison. A concrete
            subclass, <see cref="T:ICU4N.Text.RuleBasedCollator"/>, allows customization of the collation
            ordering by the use of rule sets.
            </summary>
            <remarks>
            A Collator is thread-safe only when frozen. See <see cref="P:ICU4N.Text.Collator.IsFrozen"/> and <see cref="T:ICU4N.Util.IFreezable`1"/>.
            <para/>
            Following the <a href="http://www.unicode.org">Unicode Consortium</a>'s specifications for the
            <a href="http://www.unicode.org/unicode/reports/tr10/">Unicode Collation Algorithm (UCA)</a>, 
            there are 5 different levels of strength used in comparisons:
            <list type="table">
                <item>
                    <term><see cref="F:ICU4N.Text.CollationStrength.Primary"/> strength:</term>
                    <description>
                        Typically, this is used to denote differences between
                        base characters (for example, "a" &lt; "b").
                        It is the strongest difference. For example, dictionaries are divided
                        into different sections by base character.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Text.CollationStrength.Secondary"/> strength:</term>
                    <description>
                        Accents in the characters are considered secondary
                        differences (for example, "as" &lt; "&amp;agrave;s" &lt; "at"). Other
                        differences between letters can also be considered secondary differences, depending
                        on the language. A secondary difference is ignored when there is a
                        primary difference anywhere in the strings.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Text.CollationStrength.Tertiary"/> strenth:</term>
                    <description>
                        Upper and lower case differences in characters are
                        distinguished at tertiary strength (for example, "ao" &lt; "Ao" &lt;
                        "a&amp;ograve;"). In addition, a variant of a letter differs from the base
                        form on the tertiary strength (such as "A" and ""). Another
                        example is the difference between large and small Kana. A tertiary difference is ignored
                        when there is a primary or secondary difference anywhere in the strings.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Text.CollationStrength.Quaternary"/> strenth:</term>
                    <description>
                        When punctuation is ignored
                        (see <a href="http://userguide.icu-project.org/collation/concepts#TOC-Ignoring-Punctuation">
                        Ignoring Punctuations in the User Guide</a>) at <see cref="F:ICU4N.Text.CollationStrength.Primary"/> to 
                        <see cref="F:ICU4N.Text.CollationStrength.Tertiary"/> strength, an additional strength level can
                        be used to distinguish words with and without punctuation (for example,
                        "ab" &lt; "a-b" &lt; "aB").
                        This difference is ignored when there is a <see cref="F:ICU4N.Text.CollationStrength.Primary"/>, 
                        <see cref="F:ICU4N.Text.CollationStrength.Secondary"/> or <see cref="F:ICU4N.Text.CollationStrength.Tertiary"/>
                        difference. The <see cref="F:ICU4N.Text.CollationStrength.Quaternary"/> strength should only be used if ignoring
                        punctuation is required.
                    </description>
                </item>
                <item>
                    <term><see cref="F:ICU4N.Text.CollationStrength.Identical"/> strength:</term>
                    <description>
                        When all other strengths are equal, the <see cref="F:ICU4N.Text.CollationStrength.Identical"/> strength is used as a
                        tiebreaker. The Unicode code point values of the NFD form of each string
                        are compared, just in case there is no difference.
                        For example, Hebrew cantellation marks are only distinguished at this
                        strength. This strength should be used sparingly, as only code point
                        value differences between two strings is an extremely rare occurrence.
                        Using this strength substantially decreases the performance for both
                        comparison and collation key generation APIs. This strength also
                        increases the size of the collation key.
                    </description>
                </item>
            </list>
            <para/>
            Unlike the JDK, ICU4N's Collator deals only with 2 decomposition modes,
            the canonical decomposition mode and one that does not use any decomposition.
            The compatibility decomposition mode, java.text.Collator.FULL_DECOMPOSITION
            is not supported here. If the canonical
            decomposition mode is set, the Collator handles un-normalized text properly,
            producing the same results as if the text were normalized in NFD. If
            canonical decomposition is turned off, it is the user's responsibility to
            ensure that all text is already in the appropriate form before performing
            a comparison or before getting a <see cref="T:ICU4N.Text.CollationKey"/>.
            <para/>
            For more information about the collation service see the
            <a href="http://userguide.icu-project.org/collation">User Guide</a>.
            <para/>
            Examples of use
            <code>
                // Get the Collator for US English and set its strength to CollationStrength.Primary
                Collator usCollator = Collator.GetInstance(new CultureInfo("en-us"));
                usCollator.Strength = CollationStrength.Primary;
                if (usCollator.Compare("abc", "ABC") == 0)
                {
                    Console.WriteLine("Strings are equivalent");
                }
            </code>
            The following example shows how to compare two strings using the
            <see cref="T:ICU4N.Text.Collator"/> for the default locale.
            <code>
                // Compare two strings in the default locale
                Collator myCollator = Collator.GetInstance();
                myCollator.Decomposition = NormalizationMode.NoDecomposition;
                if (myCollator.Compare("&amp;agrave;&#92;u0325", "a&#92;u0325&#768;") != 0)
                {
                    Console.WriteLine("&amp;agrave;&#92;u0325 is not equals to a&#92;u0325&#768; without decomposition");
                    myCollator.Decomposition = NormalizationMode.CanonicalDecomposition;
                    if (myCollator.Compare("&amp;agrave;&#92;u0325", "a&#92;u0325&#768;") != 0)
                    {
                        Console.WriteLine("Error: &amp;agrave;&#92;u0325 should be equals to a&#92;u0325&#768; with decomposition");
                    }
                    else
                    {
                        Console.WriteLine("&amp;agrave;&#92;u0325 is equals to a&#92;u0325&#768; with decomposition");
                    }
                }
                else
                {
                    Console.WriteLine("Error: &amp;agrave;&#92;u0325 should be not equals to a&#92;u0325&#768; without decomposition");
                }
            </code>
            </remarks>
            <seealso cref="T:ICU4N.Text.RuleBasedCollator"/>
            <seealso cref="T:ICU4N.Text.CollationKey"/>
            <author>Syn Wee Quek</author>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Collator.Primary">
            <summary>
            Strongest collator strength value. Typically used to denote differences
            between base characters. See class documentation for more explanation.
            </summary>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Collator.Secondary">
            <summary>
            Second level collator strength value.
            Accents in the characters are considered secondary differences.
            Other differences between letters can also be considered secondary
            differences, depending on the language.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Diacritical differences on the same base letter represent a secondary
            difference.  Set comparison level to Secondary to ignore tertiary
            differences.
            Example of secondary difference, "a&#x308;" >> "a".
            </summary>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Collator.Tertiary">
            <summary>
            Third level collator strength value.
            Upper and lower case differences in characters are distinguished at this
            strength level. In addition, a variant of a letter differs from the base
            form on the tertiary level.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Set comparison level to Tertiary to include
            all comparison differences.
            Example of tertiary difference, "abc" &lt;&lt;&lt; "ABC".
            </summary>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Collator.Quaternary">
            <summary>
            <icu/>Fourth level collator strength value.
            When punctuation is ignored
            (see <a href="http://userguide.icu-project.org/collation/concepts#TOC-Ignoring-Punctuation">Ignoring Punctuation in the User Guide</a>) 
            at <see cref="F:ICU4N.Text.Collator.Primary"/> to <see cref="F:ICU4N.Text.Collator.Tertiary"/>
            strength, an additional strength level can
            be used to distinguish words with and without punctuation.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Quaternary level is usually only affected by the number of
            non-ignorable code points in the string.
            </summary>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Collator.Identical">
            <summary>
            Smallest <see cref="T:ICU4N.Text.Collator"/> strength value. When all other strengths are equal,
            the IDENTICAL strength is used as a tiebreaker. The Unicode code point
            values of the NFD form of each string are compared, just in case there
            is no difference.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Note this value is different from JDK's
            <para/>
            Two characters are considered "identical" when they have the same
            unicode spellings.
            For example, "a&#x308;" == "a&#x308;".
            </summary>
            <remarks>Identical strength is rarely useful, as it amounts to
            codepoints of the NFD form of the string</remarks>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Collator.NoDecomposition">
            <summary>
            Decomposition mode value. With <see cref="F:ICU4N.Text.Collator.NoDecomposition"/> set, Strings
            will not be decomposed for collation. This is the default
            decomposition setting unless otherwise specified by the locale
            used to create the <see cref="T:ICU4N.Text.Collator"/>.
            <para/>
            <strong>Note</strong> this value is different from the JDK's.
            </summary>
            <seealso cref="F:ICU4N.Text.Collator.CanonicalDecomposition"/>
            <see cref="P:ICU4N.Text.Collator.Decomposition"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Collator.CanonicalDecomposition">
            <summary>
            Decomposition mode value. With CANONICAL_DECOMPOSITION set,
            characters that are canonical variants according to the Unicode standard
            will be decomposed for collation.
            <para/>
            CANONICAL_DECOMPOSITION corresponds to Normalization Form D as
            described in <a href="http://www.unicode.org/unicode/reports/tr15/">Unicode Technical Report #15</a>.
            </summary>
            <see cref="F:ICU4N.Text.Collator.NoDecomposition"/>
            <see cref="P:ICU4N.Text.Collator.Decomposition"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.Equals(System.Object)">
            <summary>
            Compares the equality of two <see cref="T:ICU4N.Text.Collator"/> objects. <see cref="T:ICU4N.Text.Collator"/> objects are equal if they have the same
            collation (sorting &amp; searching) behavior.
            <para/>
            The base class checks for null and for equal types.
            Subclasses should override.
            </summary>
            <param name="obj">The <see cref="T:ICU4N.Text.Collator"/> to compare to.</param>
            <returns><c>true</c> if this <see cref="T:ICU4N.Text.Collator"/> has exactly the same collation behavior as <paramref name="obj"/>, <c>false</c> otherwise.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetHashCode">
            <summary>
            Generates a hash code for this <see cref="T:ICU4N.Text.Collator"/> object.
            </summary>
            <returns>A hash code value.</returns>
            <stable>ICU 58</stable>
        </member>
        <member name="P:ICU4N.Text.Collator.Strength">
            <summary>
            Gets or sets this <see cref="T:ICU4N.Text.Collator"/>'s strength attribute. The strength attribute
            determines the minimum level of difference considered significant
            during comparison.
            <para/>
            The base class setter does nothing. The base class getter always 
            returns <see cref="F:ICU4N.Text.CollationStrength.Tertiary"/>. Subclasses should override it if appropriate.
            <para/>
            See the <see cref="T:ICU4N.Text.Collator"/> class description for an example of use.
            </summary>
            <seealso cref="F:ICU4N.Text.CollationStrength.Primary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Secondary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Tertiary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Quaternary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Identical"/>
            <exception cref="T:System.ArgumentException">if the new strength value is not valid.</exception>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.SetStrength2(ICU4N.Text.CollationStrength)">
            <summary>
            Internal, used in UnicodeTools.
            </summary>
            <param name="newStrength"></param>
            <returns>this, for chaining</returns>
        </member>
        <member name="P:ICU4N.Text.Collator.Decomposition">
            <summary>
            Gets or sets the decomposition mode of this <see cref="T:ICU4N.Text.Collator"/>.  Setting this
            decomposition attribute with <see cref="F:ICU4N.Text.NormalizationMode.CanonicalDecomposition"/> allows the
            <see cref="T:ICU4N.Text.Collator"/> to handle un-normalized text properly, producing the
            same results as if the text were normalized. If
            <see cref="F:ICU4N.Text.NormalizationMode.NoDecomposition"/> is set, it is the user's responsibility to
            insure that all text is already in the appropriate form before
            a comparison or before getting a <see cref="T:ICU4N.Text.CollationKey"/>. Adjusting
            decomposition mode allows the user to select between faster and
            more complete collation behavior. The decomposition mode
            determines how Unicode composed characters are handled.
            See the <see cref="T:ICU4N.Text.Collator"/> description for more details.
            <para/>
            Since a great many of the world's languages do not require
            text normalization, most locales set <see cref="F:ICU4N.Text.NormalizationMode.NoDecomposition"/> as the
            default decomposition mode.
            <para/>
            The base class setter does nothing. The base class method always returns <see cref="F:ICU4N.Text.NormalizationMode.NoDecomposition"/>
            Subclasses should override it if appropriate.
            </summary>
            <seealso cref="F:ICU4N.Text.NormalizationMode.NoDecomposition"/>
            <seealso cref="F:ICU4N.Text.NormalizationMode.CanonicalDecomposition"/>
            <exception cref="T:System.ArgumentException">If the given value is not a valid decomposition mode.</exception>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.SetReorderCodes(System.Int32[])">
            <summary>
            Sets the reordering codes for this collator.
            Collation reordering allows scripts and some other groups of characters
            to be moved relative to each other. This reordering is done on top of
            the DUCET/CLDR standard collation order. Reordering can specify groups to be placed
            at the start and/or the end of the collation order. These groups are specified using
            <see cref="T:ICU4N.Globalization.UScript"/> codes and <see cref="T:ICU4N.Text.ReorderCodes"/> entries.
            <para/>
            By default, reordering codes specified for the start of the order are placed in the
            order given after several special non-script blocks. These special groups of characters
            are space, punctuation, symbol, currency, and digit. These special groups are represented with
            <see cref="T:ICU4N.Text.ReorderCodes"/> entries. Script groups can be intermingled with
            these special non-script groups if those special groups are explicitly specified in the reordering.
            <para/>
            The special code <see cref="F:ICU4N.Text.ReorderCodes.Others"/>
            stands for any script that is not explicitly
            mentioned in the list of reordering codes given. Anything that is after <see cref="F:ICU4N.Text.ReorderCodes.Others"/>
            will go at the very end of the reordering in the order given.
            <para/>
            The special reorder code <see cref="F:ICU4N.Text.ReorderCodes.Default"/>
            will reset the reordering for this collator
            to the default for this collator. The default reordering may be the DUCET/CLDR order or may be a reordering that
            was specified when this collator was created from resource data or from rules. The
            DEFAULT code <b>must</b> be the sole code supplied when it is used.
            If not, then an <see cref="T:System.ArgumentException"/> will be thrown.
            <para/>
            The special reorder code <see cref="F:ICU4N.Text.ReorderCodes.None"/>
            will remove any reordering for this collator.
            The result of setting no reordering will be to have the DUCET/CLDR ordering used. The
            <see cref="F:ICU4N.Text.ReorderCodes.None"/> code <b>must</b> be the sole code supplied when it is used.
            </summary>
            <param name="order">
            The reordering codes to apply to this collator; if this is null or an empty array
            then this clears any existing reordering.
            </param>
            <seealso cref="M:ICU4N.Text.Collator.GetReorderCodes"/>
            <seealso cref="M:ICU4N.Text.Collator.GetEquivalentReorderCodes(System.Int32)"/>
            <seealso cref="T:ICU4N.Text.ReorderCodes"/>
            <seealso cref="T:ICU4N.Globalization.UScript"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetInstance">
            <summary>
            Returns the <see cref="T:ICU4N.Text.Collator"/> for the current default locale.
            The default locale is determined by <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.
            </summary>
            <returns>
            The <see cref="T:ICU4N.Text.Collator"/> for the default locale (for example, en-US) if it
            is created successfully. Otherwise if there is no <see cref="T:ICU4N.Text.Collator"/>
            associated with the current locale, the root collator
            will be returned.
            </returns>
            <seealso cref="P:System.Globalization.CultureInfo.CurrentCulture"/>
            <seealso cref="M:ICU4N.Text.Collator.GetInstance(System.Globalization.CultureInfo)"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.Clone">
            <summary>
            Clones the collator.
            </summary>
            <returns>A clone of this collator.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="T:ICU4N.Text.Collator.ASCII">
            <summary>
            Simpler/faster methods for ASCII than ones based on Unicode data.
            TODO: There should be code like this somewhere already??
            </summary>
        </member>
        <member name="M:ICU4N.Text.Collator.SetAttributesFromKeywords(ICU4N.Globalization.UCultureInfo,ICU4N.Text.Collator,ICU4N.Text.RuleBasedCollator)">
            <summary>
            Sets collation attributes according to locale keywords. See
            http://www.unicode.org/reports/tr35/tr35-collation.html#Collation_Settings
            <para/>
            Using "alias" keywords and values where defined:
            http://www.unicode.org/reports/tr35/tr35.html#Old_Locale_Extension_Syntax
            http://unicode.org/repos/cldr/trunk/common/bcp47/collation.xml
            </summary>
            <param name="loc"></param>
            <param name="coll"></param>
            <param name="rbc"></param>
        </member>
        <member name="M:ICU4N.Text.Collator.GetInstance(ICU4N.Globalization.UCultureInfo)">
            <summary>
            <icu/> Returns the <see cref="T:ICU4N.Text.Collator"/> for the desired locale.
            <para/>
            For some languages, multiple collation types are available;
            for example, "de@collation=phonebook".
            Starting with ICU 54, collation attributes can be specified via locale keywords as well,
            in the old locale extension syntax ("el@colCaseFirst=upper")
            or in language tag syntax ("el-u-kf-upper").
            See <a href="http://userguide.icu-project.org/collation/api">User Guide: Collation API</a>.
            </summary>
            <param name="locale">the desired locale.</param>
            <returns>
            <see cref="T:ICU4N.Text.Collator"/> for the desired locale if it is created successfully.
            Otherwise if there is no Collator
            associated with the current locale, the root collator will
            be returned.
            </returns>
            <seealso cref="T:System.Globalization.CultureInfo"/>
            <seealso cref="T:ICU4N.Util.ResourceBundle"/>
            <seealso cref="M:ICU4N.Text.Collator.GetInstance(System.Globalization.CultureInfo)"/>
            <seealso cref="M:ICU4N.Text.Collator.GetInstance"/>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetInstance(System.Globalization.CultureInfo)">
            <summary>
            Returns the <see cref="T:ICU4N.Text.Collator"/> for the desired locale.
            <para/>
            For some languages, multiple collation types are available;
            for example, "de-u-co-phonebk".
            Starting with ICU 54, collation attributes can be specified via locale keywords as well,
            in the old locale extension syntax ("el@colCaseFirst=upper", only with <see cref="T:ICU4N.Globalization.UCultureInfo"/>)
            or in language tag syntax ("el-u-kf-upper").
            See <a href="http://userguide.icu-project.org/collation/api">User Guide: Collation API</a>.
            </summary>
            <param name="locale">the desired locale.</param>
            <returns>
            <see cref="T:ICU4N.Text.Collator"/> for the desired locale if it is created successfully.
            Otherwise if there is no <see cref="T:ICU4N.Text.Collator"/>
            associated with the current locale, the root collator will
            be returned.
            </returns>
            <seealso cref="T:System.Globalization.CultureInfo"/>
            <seealso cref="T:ICU4N.Util.ResourceBundle"/>
            <seealso cref="M:ICU4N.Text.Collator.GetInstance(System.Globalization.CultureInfo)"/>
            <seealso cref="M:ICU4N.Text.Collator.GetInstance"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.RegisterInstance(ICU4N.Text.Collator,ICU4N.Globalization.UCultureInfo)">
            <summary>
            <icu/> Registers a collator as the default collator for the provided locale.  The
            collator should not be modified after it is registered.
            <para/>
            Because ICU may choose to cache Collator objects internally, this must
            be called at application startup, prior to any calls to
            <see cref="M:ICU4N.Text.Collator.GetInstance"/> to avoid undefined behavior.
            </summary>
            <param name="collator">the collator to register</param>
            <param name="locale">the locale for which this is the default collator</param>
            <returns>an object that can be used to unregister the registered collator.</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.RegisterFactory(ICU4N.Text.CollatorFactory)">
            <summary>
            <icu/> Registers a collator factory.
            <para/>
            Because ICU may choose to cache Collator objects internally, this must
            be called at application startup, prior to any calls to
            <see cref="M:ICU4N.Text.Collator.GetInstance"/> to avoid undefined behavior.
            </summary>
            <param name="factory">the factory to register</param>
            <returns>an object that can be used to unregister the registered factory.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.Unregister(System.Object)">
            <summary>
            <icu/> Unregisters a collator previously registered using <see cref="M:ICU4N.Text.Collator.RegisterInstance(ICU4N.Text.Collator,ICU4N.Globalization.UCultureInfo)"/>.
            </summary>
            <param name="registryKey">the object previously returned by <see cref="M:ICU4N.Text.Collator.RegisterInstance(ICU4N.Text.Collator,ICU4N.Globalization.UCultureInfo)"/>.</param>
            <returns>true if the collator was successfully unregistered.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetCultures(ICU4N.Globalization.UCultureTypes)">
            <summary>
            Returns the set of locales, as <see cref="T:System.Globalization.CultureInfo"/> objects, for which collators
            are installed.  Note that <see cref="T:System.Globalization.CultureInfo"/> objects do not support RFC 3066.
            </summary>
            <param name="types">A bitwise combination of the enumeration values that filter the cultures to retrieve.</param>
            <returns>
            the list of locales in which collators are installed.
            This list includes any that have been registered, in addition to
            those that are installed with ICU4N.
            </returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetUCultures(ICU4N.Globalization.UCultureTypes)">
            <summary>
            <icu/> Returns the set of locales, as <see cref="T:ICU4N.Globalization.UCultureInfo"/> objects, for which collators
            are installed.  <see cref="T:ICU4N.Globalization.UCultureInfo"/> objects support RFC 3066.
            </summary>
            <param name="types">A bitwise combination of the enumeration values that filter the cultures to retrieve.</param>
            <returns>
            the list of locales in which collators are installed.
            This list includes any that have been registered, in addition to
            those that are installed with ICU4N.
            </returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Text.Collator.KEYWORDS">
            <summary>
            The list of keywords for this service.  This must be kept in sync with
            the resource data.
            </summary>
            <since>ICU 3.0</since>
        </member>
        <member name="F:ICU4N.Text.Collator.RESOURCE">
            <summary>
            The resource name for this service.  Note that this is not the same as
            the keyword for this service.
            </summary>
            <since>ICU 3.0</since>
        </member>
        <member name="F:ICU4N.Text.Collator.BASE">
            <summary>
            The resource bundle base name for this service.
            </summary>
            <since>ICU 3.0</since>
        </member>
        <member name="P:ICU4N.Text.Collator.Keywords">
            <summary>
            <icu/> Returns a list of all possible keywords that are relevant to
            collation. At this point, the only recognized keyword for this
            service is "collation".
            </summary>
            <seealso cref="M:ICU4N.Text.Collator.GetKeywordValues(System.String)"/>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetKeywordValues(System.String)">
            <summary>
            <icu/> Given a keyword, returns an array of all values for
            that keyword that are currently in use.
            </summary>
            <param name="keyword">one of the keywords returned by <see cref="P:ICU4N.Text.Collator.Keywords"/>.</param>
            <returns></returns>
            <seealso cref="P:ICU4N.Text.Collator.Keywords"/>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetKeywordValuesForLocale(System.String,ICU4N.Globalization.UCultureInfo,System.Boolean)">
            <summary>
            <icu/> Given a key and a locale, returns an array of string values in a preferred
            order that would make a difference. These are all and only those values where
            the open (creation) of the service with the locale formed from the input locale
            plus input keyword and that value has different behavior than creation with the
            input locale alone.
            </summary>
            <param name="key">
            one of the keys supported by this service. For now, only
            "collation" is supported.
            </param>
            <param name="locale">the locale</param>
            <param name="commonlyUsed">if set to true it will return only commonly used values
            with the given locale in preferred order.  Otherwise,
            it will return all the available values for the locale.
            </param>
            <returns>An array of string values for the given key and the locale.</returns>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetFunctionalEquivalent(System.String,ICU4N.Globalization.UCultureInfo,System.Boolean[])">
            <summary>
            <icu/> Returns the functionally equivalent locale for the given
            requested locale, with respect to given keyword, for the
            collation service.  If two locales return the same result, then
            collators instantiated for these locales will behave
            equivalently.  The converse is not always true; two collators
            may in fact be equivalent, but return different results, due to
            internal details.  The return result has no other meaning than
            that stated above, and implies nothing as to the relationship
            between the two locales.  This is intended for use by
            applications who wish to cache collators, or otherwise reuse
            collators when possible.  The functional equivalent may change
            over time.  For more information, please see the <a
            href="http://userguide.icu-project.org/locale#TOC-Locales-and-Services">
            Locales and Services</a> section of the ICU User Guide.
            </summary>
            <param name="keyword">A particular keyword as enumerated by <see cref="P:ICU4N.Text.Collator.Keywords"/>.</param>
            <param name="locID">The requested locale</param>
            <param name="isAvailable">If non-null, <paramref name="isAvailable"/>[0] will receive and
            output boolean that indicates whether the requested locale was
            'available' to the collation service. If non-null, <paramref name="isAvailable"/>
            must have length &gt;= 1.</param>
            <returns>the locale</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetFunctionalEquivalent(System.String,ICU4N.Globalization.UCultureInfo)">
            <summary>
            <icu/> Returns the functionally equivalent locale for the given
            requested locale, with respect to given keyword, for the
            collation service.
            </summary>
            <param name="keyword">a particular keyword as enumerated by <see cref="P:ICU4N.Text.Collator.Keywords"/>.</param>
            <param name="locID">The requested locale</param>
            <returns>the locale</returns>
            <seealso cref="M:ICU4N.Text.Collator.GetFunctionalEquivalent(System.String,ICU4N.Globalization.UCultureInfo,System.Boolean[])"/>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetDisplayName(System.Globalization.CultureInfo,System.Globalization.CultureInfo)">
            <summary>
            <icu/> Returns the name of the collator for the <paramref name="objectLocale"/>, localized for the
            <paramref name="displayLocale"/>.
            </summary>
            <param name="objectLocale">the locale of the collator</param>
            <param name="displayLocale">the locale for the collator's display name</param>
            <returns>the display name</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetDisplayName(ICU4N.Globalization.UCultureInfo,ICU4N.Globalization.UCultureInfo)">
            <summary>
            <icu/> Returns the name of the collator for the <paramref name="objectLocale"/>, localized for the
            <paramref name="displayLocale"/>.
            </summary>
            <param name="objectLocale">the locale of the collator</param>
            <param name="displayLocale">the locale for the collator's display name</param>
            <returns>the display name</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetDisplayName(System.Globalization.CultureInfo)">
            <summary>
            <icu/> Returns the name of the collator for the objectLocale, localized for the
            <see cref="P:ICU4N.Globalization.UCultureInfo.CurrentUICulture"/> locale.
            </summary>
            <param name="objectLocale">the locale of the collator</param>
            <returns>the display name</returns>
            <seealso cref="P:ICU4N.Globalization.UCultureInfo.CurrentUICulture"/>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetDisplayName(ICU4N.Globalization.UCultureInfo)">
            <summary>
            <icu/> Returns the name of the collator for the <paramref name="objectLocale"/>, localized for the
            <see cref="P:ICU4N.Globalization.UCultureInfo.CurrentUICulture"/> locale.
            </summary>
            <param name="objectLocale">the locale of the collator</param>
            <returns>the display name</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.Equals(System.String,System.String)">
            <summary>
            Compares the equality of two text Strings using
            this <see cref="T:ICU4N.Text.Collator"/>'s rules, strength and decomposition mode.  Convenience method.
            </summary>
            <param name="source">the source string to be compared.</param>
            <param name="target">the target string to be compared.</param>
            <returns>true if the strings are equal according to the collation rules, otherwise false.</returns>
            <exception cref="T:System.ArgumentNullException">thrown if either arguments is null.</exception>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetTailoredSet">
            <summary>
            <icu/> Returns a <see cref="T:ICU4N.Text.UnicodeSet"/> that contains all the characters and sequences tailored
            in this collator.
            </summary>
            <returns>
            A pointer to a UnicodeSet object containing all the
            code points and sequences that may sort differently than
            in the root collator.
            </returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.Compare(System.String,System.String)">
            <summary>
            Compares the source text <see cref="T:System.String"/> to the target text <see cref="T:System.String"/> according to
            this <see cref="T:ICU4N.Text.Collator"/>'s rules, strength and decomposition mode.
            Returns an integer less than,
            equal to or greater than zero depending on whether the source String is
            less than, equal to or greater than the target <see cref="T:System.String"/>. See the <see cref="T:ICU4N.Text.Collator"/>
            class description for an example of use.
            </summary>
            <param name="source">the source string.</param>
            <param name="target">the target string.</param>
            <returns>
            Returns an integer value. Value is less than zero if source is
            less than target, value is zero if source and target are equal,
            value is greater than zero if source is greater than target.
            </returns>
            <exception cref="T:System.ArgumentNullException">thrown if either argument is null.</exception>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.Compare(System.Object,System.Object)">
            <summary>
            Compares the source <see cref="T:System.Object"/> to the target <see cref="T:System.Object"/>.
            </summary>
            <param name="source">the source <see cref="T:System.Object"/>.</param>
            <param name="target">the target <see cref="T:System.Object"/>.</param>
            <returns>
            Returns an integer value. Value is less than zero if source is
            less than target, value is zero if source and target are equal,
            value is greater than zero if source is greater than target.
            </returns>
            <exception cref="T:System.InvalidCastException">thrown if either arguments cannot be cast to <see cref="T:System.String"/>.</exception>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.DoCompare(J2N.Text.ICharSequence,J2N.Text.ICharSequence)">
            <summary>
            Compares two <see cref="T:J2N.Text.ICharSequence"/>s.
            The base class just calls <c>Compare(left.ToString(), right.ToString())</c>.
            Subclasses should instead implement this method and have the String API call this method.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Text.Collator.GetCollationKey(System.String)">
            <summary>
            Transforms the <see cref="T:System.String"/> into a <see cref="T:ICU4N.Text.CollationKey"/> suitable for efficient
            repeated comparison.  The resulting key depends on the collator's
            rules, strength and decomposition mode.
            <para/>
            Note that collation keys are often less efficient than simply doing comparison.
            For more details, see the ICU User Guide.
            <para/>
            See the CollationKey class documentation for more information.
            </summary>
            <param name="source">the <see cref="T:System.String"/> to be transformed into a <see cref="T:ICU4N.Text.CollationKey"/>.</param>
            <returns>
            The <see cref="T:ICU4N.Text.CollationKey"/> for the given <see cref="T:System.String"/> based on this <see cref="T:ICU4N.Text.Collator"/>'s
            collation rules. If the source <see cref="T:System.String"/> is null, a null
            <see cref="T:ICU4N.Text.CollationKey"/> is returned.
            </returns>
            <seealso cref="T:ICU4N.Text.CollationKey"/>
            <seealso cref="M:ICU4N.Text.Collator.Compare(System.String,System.String)"/>
            <seealso cref="M:ICU4N.Text.Collator.GetRawCollationKey(System.String,ICU4N.Text.RawCollationKey)"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetRawCollationKey(System.String,ICU4N.Text.RawCollationKey)">
            <summary>
            <icu/> Returns the simpler form of a <see cref="T:ICU4N.Text.CollationKey"/> for the String source following
            the rules of this Collator and stores the result into the user provided argument
            key.  If key has a internal byte array of length that's too small for the result,
            the internal byte array will be grown to the exact required size.
            <para/>
            Note that collation keys are often less efficient than simply doing comparison.
            For more details, see the ICU User Guide.
            </summary>
            <param name="source">the text <see cref="T:System.String"/> to be transformed into a <see cref="T:ICU4N.Text.RawCollationKey"/></param>
            <param name="key"></param>
            <returns>
            If key is null, a new instance of <see cref="T:ICU4N.Text.RawCollationKey"/> will be
            created and returned, otherwise the user provided key will be
            returned.
            </returns>
            <seealso cref="M:ICU4N.Text.Collator.Compare(System.String,System.String)"/>
            <seealso cref="M:ICU4N.Text.Collator.GetCollationKey(System.String)"/>
            <seealso cref="T:ICU4N.Text.RawCollationKey"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="P:ICU4N.Text.Collator.MaxVariable">
            <summary>
            <icu/> Gets or sets the variable top to the top of the specified reordering group.
            The variable top determines the highest-sorting character
            which is affected by the alternate handling behavior.
            If that attribute is set to UCOL_NON_IGNORABLE, then the variable top has no effect.
            <para/>
            The base class setter throws a <see cref="T:System.NotSupportedException"/> and the getter
            returns <see cref="F:ICU4N.Text.ReorderCodes.Punctuation"/>.
            <para/>
            Valid values are one of <see cref="F:ICU4N.Text.ReorderCodes.Space"/>, <see cref="F:ICU4N.Text.ReorderCodes.Punctuation"/>,
            <see cref="F:ICU4N.Text.ReorderCodes.Symbol"/>, <see cref="F:ICU4N.Text.ReorderCodes.Currency"/>; 
            or <see cref="F:ICU4N.Text.ReorderCodes.Default"/> to restore the default max variable group.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.SetVariableTop(System.String)">
            <summary>
            <icu/> Sets the variable top to the primary weight of the specified string.
            <para/>
            Beginning with ICU 53, the variable top is pinned to
            the top of one of the supported reordering groups,
            and it must not be beyond the last of those groups.
            See the setter of <see cref="P:ICU4N.Text.Collator.MaxVariable"/>.
            </summary>
            <param name="varTop">
            one or more (if contraction) characters to which the
            variable top should be set
            </param>
            <returns>variable top primary weight</returns>
            <exception cref="T:System.ArgumentException">
            is thrown if varTop argument is not a valid variable top element. A variable top element is
            invalid when
            <list type="bullet">
                <item><description>it is a contraction that does not exist in the Collation order</description></item>
                <item><description>the variable top is beyond the last reordering group supported by <see cref="P:ICU4N.Text.Collator.MaxVariable"/></description></item>
                <item><description>when the <paramref name="varTop"/> argument is null or zero in length.</description></item>
            </list>
            </exception>
            <seealso cref="P:ICU4N.Text.RuleBasedCollator.IsAlternateHandlingShifted"/>
        </member>
        <member name="P:ICU4N.Text.Collator.VariableTop">
            <summary>
            Gets or sets the variable top to the specified primary weight.
            <para/>
            Beginning with ICU 53, the variable top is pinned to
            the top of one of the supported reordering groups,
            and it must not be beyond the last of those groups.
            See the setter for <see cref="P:ICU4N.Text.Collator.MaxVariable"/>.
            </summary>
            <seealso cref="M:ICU4N.Text.Collator.SetVariableTop(System.String)"/>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetVersion">
            <summary>
            <icu/> Returns the version of this collator object.
            </summary>
            <returns>the version object associated with this collator</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetUCAVersion">
            <summary>
            <icu/> Returns the UCA version of this collator object.
            </summary>
            <returns>the version object associated with this collator</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetReorderCodes">
            <summary>
            Retrieves the reordering codes for this collator.
            These reordering codes are a combination of <see cref="T:ICU4N.Globalization.UScript"/> codes and <see cref="T:ICU4N.Text.ReorderCodes"/>.
            </summary>
            <returns>
            a copy of the reordering codes for this collator;
            if none are set then returns an empty array
            </returns>
            <seealso cref="M:ICU4N.Text.Collator.SetReorderCodes(System.Int32[])"/>
            <seealso cref="M:ICU4N.Text.Collator.GetEquivalentReorderCodes(System.Int32)"/>
            <seealso cref="T:ICU4N.Text.ReorderCodes"/>
            <seealso cref="T:ICU4N.Globalization.UScript"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetEquivalentReorderCodes(System.Int32)">
            <summary>
            Retrieves all the reorder codes that are grouped with the given reorder code. Some reorder
            codes are grouped and must reorder together.
            Beginning with ICU 55, scripts only reorder together if they are primary-equal,
            for example Hiragana and Katakana.
            </summary>
            <param name="reorderCode">The reorder code to determine equivalence for.</param>
            <returns>The set of all reorder codes in the same group as the given reorder code.</returns>
            <seealso cref="M:ICU4N.Text.Collator.SetReorderCodes(System.Int32[])"/>
            <seealso cref="M:ICU4N.Text.Collator.GetReorderCodes"/>
            <seealso cref="T:ICU4N.Text.ReorderCodes"/>
            <seealso cref="T:ICU4N.Globalization.UScript"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.Collator.IsFrozen">
            <summary>
            Determines whether the object has been frozen or not.
            <para/>
            An unfrozen <see cref="T:ICU4N.Text.Collator"/> is mutable and not thread-safe.
            A frozen <see cref="T:ICU4N.Text.Collator"/> is immutable and thread-safe.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.Freeze">
            <summary>
            Freezes the collator.
            </summary>
            <returns>The collator itself.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.CloneAsThawed">
            <summary>
            Provides for the clone operation. Any clone is initially unfrozen.
            </summary>
            <returns></returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.#ctor">
            <summary>
            Empty default constructor
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="P:ICU4N.Text.Collator.ActualCulture">
            <summary>
            <icu/> Gets the locale that was used to create this object, or <c>null</c>.
            <para/>
            Indicates the locale of the resource containing the data. This is always
            at or above the valid locale. If the valid locale does not contain the
            specific data being requested, then the actual locale will be
            above the valid locale. If the object was not constructed from
            locale data, then the valid locale is <c>null</c>.
            <para/>
            This may may differ from the locale requested at the time of
            this object's creation. For example, if an object is created
            for locale <c>en_US_CALIFORNIA</c>, the actual data may be
            drawn from <c>en</c> (the <i>actual</i> locale), and
            <c>en_US</c> may be the most specific locale that exists (the
            <i>valid</i> locale).
            <para/>
            Note: This property will be implemented in ICU 3.0; ICU 2.8
            contains a partial preview implementation. The * <i>actual</i>
            locale is returned correctly, but the <i>valid</i> locale is
            not, in most cases.
            <para/>
            The base class method always returns <see cref="P:ICU4N.Globalization.UCultureInfo.InvariantCulture"/>
            Subclasses should override it if appropriate.
            </summary>
            <seealso cref="T:ICU4N.Globalization.UCultureInfo"/>
            <draft>ICU 2.8 (retain)</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="P:ICU4N.Text.Collator.ValidCulture">
            <summary>
            <icu/> Gets the locale that was used to create this object, or <c>null</c>.
            <para/>
            Indicates the most specific locale for which any data exists.
            This is always at or above the requested locale, and at or below
            the actual locale. If the requested locale does not correspond
            to any resource data, then the valid locale will be above the
            requested locale. If the object was not constructed from locale
            data, then the actual locale is <c>null</c>.
            <para/>
            This may may differ from the locale requested at the time of
            this object's creation. For example, if an object is created
            for locale <c>en_US_CALIFORNIA</c>, the actual data may be
            drawn from <c>en</c> (the <i>actual</i> locale), and
            <c>en_US</c> may be the most specific locale that exists (the
            <i>valid</i> locale).
            <para/>
            Note: This property will be implemented in ICU 3.0; ICU 2.8
            contains a partial preview implementation. The * <i>actual</i>
            locale is returned correctly, but the <i>valid</i> locale is
            not, in most cases.
            <para/>
            The base class method always returns <see cref="P:ICU4N.Globalization.UCultureInfo.InvariantCulture"/>
            Subclasses should override it if appropriate.
            </summary>
            <seealso cref="T:ICU4N.Globalization.UCultureInfo"/>
            <draft>ICU 2.8 (retain)</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.Collator.SetCulture(ICU4N.Globalization.UCultureInfo,ICU4N.Globalization.UCultureInfo)">
            <summary>
            Set information about the locales that were used to create this
            object.  If the object was not constructed from locale data,
            both arguments should be set to null.  Otherwise, neither
            should be null.  The actual locale must be at the same level or
            less specific than the valid locale. This method is intended
            for use by factories or other entities that create objects of
            this class.
            <para/>
            The base class method does nothing. Subclasses should override it if appropriate.
            </summary>
            <param name="valid">The most specific locale containing any resource data, or <c>null</c>.</param>
            <param name="actual">The locale containing data used to construct this object, or <c>null</c>.</param>
            <seealso cref="T:ICU4N.Globalization.UCultureInfo"/>
        </member>
        <member name="M:ICU4N.Text.CollatorServiceShim.CService.ValidateFallbackLocale">
            <summary>
            <see cref="M:ICU4N.Text.CollatorServiceShim.MakeInstance(ICU4N.Globalization.UCultureInfo)"/> returns an appropriate <see cref="T:ICU4N.Text.Collator"/> for any locale.
            It falls back to root if there is no specific data.
            <para/>
            Without this override, the service code would fall back to the default locale
            which is not desirable for an algorithm with a good Unicode default,
            like collation.
            </summary>
        </member>
        <member name="T:ICU4N.Text.RawCollationKey">
            <summary>
            Simple class wrapper to store the internal byte representation of a 
            <see cref="T:ICU4N.Text.CollationKey"/>. Unlike the <see cref="T:ICU4N.Text.CollationKey"/>, this class do not contain information 
            on the source string the sort order represents. <see cref="T:ICU4N.Text.RawCollationKey"/> is mutable 
            and users can reuse its objects with the method in 
            <see cref="M:ICU4N.Text.RuleBasedCollator.GetRawCollationKey(System.String,ICU4N.Text.RawCollationKey)"/>.
            </summary>
            <remarks>
            Please refer to the documentation on <see cref="T:ICU4N.Text.CollationKey"/> for a detail description
            on the internal byte representation. Note the internal byte representation 
            is always null-terminated.
            <para/>
            <code>
            // Example of use:
            string str[] = {.....};
            RuleBasedCollator collator = (RuleBasedCollator)Collator.GetInstance();
            RawCollationKey key = new RawCollationKey(128);
            for (int i = 0; i &lt; str.length; i++)
            {
                collator.GetRawCollationKey(str[i], key);
                // do something with key.Bytes
            }
            </code>
            <para/>
            <strong>Note:</strong> Comparison between <see cref="T:ICU4N.Text.RawCollationKey"/>s created by
            different <see cref="T:ICU4N.Text.Collator"/>s might return incorrect results.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for details.
            </remarks>
            <stable>ICU 2.8</stable>
            <seealso cref="T:ICU4N.Text.RuleBasedCollator"/>
            <seealso cref="T:ICU4N.Text.CollationKey"/>
        </member>
        <member name="M:ICU4N.Text.RawCollationKey.#ctor">
            <summary>
            Default constructor, internal byte array is null and its size set to 0.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RawCollationKey.#ctor(System.Int32)">
            <summary>
            RawCollationKey created with an empty internal byte array of length 
            capacity. Size of the internal byte array will be set to 0.
            </summary>
            <param name="capacity">Length of internal byte array.</param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RawCollationKey.#ctor(System.Byte[])">
            <summary>
            <see cref="T:ICU4N.Text.RawCollationKey"/> created, adopting bytes as the internal byte array.
            <para/>
            Size of the internal byte array will be set to 0.
            </summary>
            <param name="bytes">Byte array to be adopted by <see cref="T:ICU4N.Text.RawCollationKey"/>.</param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RawCollationKey.#ctor(System.Byte[],System.Int32)">
            <summary>
            Construct a <see cref="T:ICU4N.Text.RawCollationKey"/> from a byte array and size.
            </summary>
            <param name="bytesToAdopt">The byte array to adopt.</param>
            <param name="size">The length of valid data in the byte array.</param>
            <exception cref="T:System.IndexOutOfRangeException">If bytesToAdopt == null and size != 0, or
            size &lt; 0, or size &gt; bytesToAdopt.length.</exception>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RawCollationKey.CompareTo(ICU4N.Util.ByteArrayWrapper)">
            <summary>
            Compare this <see cref="T:ICU4N.Text.RawCollationKey"/> to another, which must not be null.  This overrides
            the inherited implementation to ensure the returned values are -1, 0, or 1.
            </summary>
            <param name="rhs">The <see cref="T:ICU4N.Text.RawCollationKey"/> to compare to.</param>
            <returns>-1, 0, or 1 as this compares less than, equal to, or
            greater than rhs.</returns>
            <stable>ICU 4.4</stable>
        </member>
        <member name="T:ICU4N.Text.RuleBasedCollator">
            <summary>
            <see cref="T:ICU4N.Text.RuleBasedCollator"/> is a concrete subclass of <see cref="T:ICU4N.Text.Collator"/>. It allows customization of the <see cref="T:ICU4N.Text.Collator"/> via user-specified rule
            sets. <see cref="T:ICU4N.Text.RuleBasedCollator"/> is designed to be fully compliant to the <a
            href="http://www.unicode.org/unicode/reports/tr10/">Unicode Collation Algorithm (UCA)</a> and conforms to ISO 14651.
            <para/>
            A <see cref="T:ICU4N.Text.Collator"/> is thread-safe only when frozen. See <see cref="P:ICU4N.Text.RuleBasedCollator.IsFrozen"/> and <see cref="T:ICU4N.Util.IFreezable`1"/>.
            <para/>
            Users are strongly encouraged to read the <a href="http://userguide.icu-project.org/collation">User
            Guide</a> for more information about the collation service before using this class.
            </summary>
            <remarks>
            Create a <see cref="T:ICU4N.Text.RuleBasedCollator"/> from a locale by calling the <see cref="M:ICU4N.Text.Collator.GetInstance(System.Globalization.CultureInfo)"/> factory method in the base class
            <see cref="T:ICU4N.Text.Collator"/>. <see cref="M:ICU4N.Text.Collator.GetInstance(System.Globalization.CultureInfo)"/> creates a <see cref="T:ICU4N.Text.RuleBasedCollator"/> object based on the collation rules defined by the
            argument locale. If a customized collation ordering or attributes is required, use the <see cref="M:ICU4N.Text.RuleBasedCollator.#ctor(System.String)"/>
            constructor with the appropriate rules. The customized <see cref="T:ICU4N.Text.RuleBasedCollator"/> will base its ordering on the CLDR root collation, while
            re-adjusting the attributes and orders of the characters in the specified rule accordingly.
            <para/>
            RuleBasedCollator provides correct collation orders for most locales supported in ICU. If specific data for a locale
            is not available, the orders eventually falls back to the
            <a href="http://www.unicode.org/reports/tr35/tr35-collation.html#Root_Collation">CLDR root sort order</a>.
            <para/>
            For information about the collation rule syntax and details about customization, please refer to the <a
            href="http://userguide.icu-project.org/collation/customization">Collation customization</a> section of the
            User Guide.
            <para/>
            Note that
            ICU4N's <see cref="T:ICU4N.Text.RuleBasedCollator"/> does not support turning off the Thai/Lao vowel-consonant swapping using '!', since the UCA clearly
            states that it has to be supported to ensure a correct sorting order. If a '!' is encountered, it is ignored.
            <para/>
            <strong>Examples</strong>
            <para/>
            Creating Customized <see cref="T:ICU4N.Text.RuleBasedCollator"/>s: 
            <code>
            string simple = "&amp; a &lt; b &lt; c &lt; d";
            RuleBasedCollator simpleCollator = new RuleBasedCollator(simple);
            
            string norwegian = "&amp; a , A &lt; b , B &lt; c , C &lt; d , D &lt; e , E "
                               + "&lt; f , F &lt; g , G &lt; h , H &lt; i , I &lt; j , "
                               + "J &lt; k , K &lt; l , L &lt; m , M &lt; n , N &lt; "
                               + "o , O &lt; p , P &lt; q , Q &lt;r , R &lt;s , S &lt; "
                               + "t , T &lt; u , U &lt; v , V &lt; w , W &lt; x , X "
                               + "&lt; y , Y &lt; z , Z &lt; &#92;u00E5 = a&#92;u030A "
                               + ", &#92;u00C5 = A&#92;u030A ; aa , AA &lt; &#92;u00E6 "
                               + ", &#92;u00C6 &lt; &#92;u00F8 , &#92;u00D8";
            RuleBasedCollator norwegianCollator = new RuleBasedCollator(norwegian);
            </code>
            <para/>
            Concatenating rules to combine <c>Collator</c>s:
            <code>
            // Create an en-US Collator object
            RuleBasedCollator en_USCollator = (RuleBasedCollator)Collator.GetInstance(new CultureInfo("en-US"));
            // Create a da-DK Collator object
            RuleBasedCollator da_DKCollator = (RuleBasedCollator)Collator.GetInstance(new CultureInfo("da-DK"));
            
            // Combine the two
            
            // First, get the collation rules from en_USCollator
            string en_USRules = en_USCollator.GetRules();
            // Second, get the collation rules from da_DKCollator
            string da_DKRules = da_DKCollator.GetRules();
            RuleBasedCollator newCollator = new RuleBasedCollator(en_USRules + da_DKRules);
            // newCollator has the combined rules
            </code>
            <para/>
            Making changes to an existing <see cref="T:ICU4N.Text.RuleBasedCollator"/> to create a new <c>Collator</c> object, by appending changes to
            the existing rule: 
            <code>
            // Create a new Collator object with additional rules
            string addRules = "&amp; C &lt; ch, cH, Ch, CH";
            RuleBasedCollator myCollator = new RuleBasedCollator(en_USCollator.GetRules() + addRules);
            // myCollator contains the new rules
            </code>
            <para/>
            How to change the order of non-spacing accents: 
            <code>
            // old rule with main accents
            string oldRules = "= &#92;u0301 ; &#92;u0300 ; &#92;u0302 ; &#92;u0308 "
                            + "; &#92;u0327 ; &#92;u0303 ; &#92;u0304 ; &#92;u0305 "
                            + "; &#92;u0306 ; &#92;u0307 ; &#92;u0309 ; &#92;u030A "
                            + "; &#92;u030B ; &#92;u030C ; &#92;u030D ; &#92;u030E "
                            + "; &#92;u030F ; &#92;u0310 ; &#92;u0311 ; &#92;u0312 "
                            + "&lt; a , A ; ae, AE ; &#92;u00e6 , &#92;u00c6 "
                            + "&lt; b , B &lt; c, C &lt; e, E &amp; C &lt; d , D";
            // change the order of accent characters
            string addOn = "&amp; &#92;u0300 ; &#92;u0308 ; &#92;u0302";
            RuleBasedCollator myCollator = new RuleBasedCollator(oldRules + addOn);
            </code>
            <para/>
            Putting in a new primary ordering before the default setting, e.g. sort English characters before or after Japanese
            characters in the Japanese <c>Collator</c>:
            <code>
            // get en_US Collator rules
            RuleBasedCollator en_USCollator = (RuleBasedCollator)Collator.GetInstance(new CultureInfo("en-US"));
            // add a few Japanese characters to sort before English characters
            // suppose the last character before the first base letter 'a' in
            // the English collation rule is &#92;u2212
            string jaString = "&amp; &#92;u2212 &lt;&#92;u3041, &#92;u3042 &lt;&#92;u3043, "
                              + "&#92;u3044";
            RuleBasedCollator myJapaneseCollator = new RuleBasedCollator(en_USCollator.GetRules() + jaString);
            </code>
            <para/>
            This class cannot be inherited.
            </remarks>
            <author>Syn Wee Quek</author>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.#ctor(System.String)">
            <summary>
            Constructor that takes the argument rules for customization.
            The collator will be based on the CLDR root collation, with the
            attributes and re-ordering of the characters specified in the argument rules.
            <para/>
            See the User Guide's section on <a href="http://userguide.icu-project.org/collation/customization">
            Collation Customization</a> for details on the rule syntax.
            </summary>
            <param name="rules">The collation rules to build the collation table from.</param>
            <exception cref="T:System.FormatException">Thrown when argument rules have an invalid syntax.</exception>
            <exception cref="T:System.IO.IOException">Thrown when an error occurred while reading internal data.</exception>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.InternalBuildTailoring(System.String)">
            <summary>
            Implements from-rule constructors.
            </summary>
            <param name="rules">Rule string.</param>
            <exception cref="T:System.Exception"/>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.Clone">
            <summary>
            Clones the <see cref="T:ICU4N.Text.RuleBasedCollator"/>.
            </summary>
            <returns>A new instance of this <see cref="T:ICU4N.Text.RuleBasedCollator"/> object.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetCollationElementIterator(System.String)">
            <summary>
            Return a <see cref="T:ICU4N.Text.CollationElementIterator"/> for the given <see cref="T:System.String"/>.
            </summary>
            <seealso cref="T:ICU4N.Text.CollationElementIterator"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetCollationElementIterator(ICU4N.Support.Text.CharacterIterator)">
            <summary>
            Return a <see cref="T:ICU4N.Text.CollationElementIterator"/> for the given <see cref="T:ICU4N.Support.Text.CharacterIterator"/>. The source iterator's integrity will be
            preserved since a new copy will be created for use.
            </summary>
            <seealso cref="T:ICU4N.Text.CollationElementIterator"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetCollationElementIterator(ICU4N.Text.UCharacterIterator)">
            <summary>
            Return a <see cref="T:ICU4N.Text.CollationElementIterator"/> for the given <see cref="T:ICU4N.Text.UCharacterIterator"/>. The source iterator's integrity will be
            preserved since a new copy will be created for use.
            </summary>
            <seealso cref="T:ICU4N.Text.CollationElementIterator"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.IsFrozen">
            <summary>
            Determines whether the object has been frozen or not.
            <para/>
            An unfrozen <see cref="T:ICU4N.Text.Collator"/> is mutable and not thread-safe.
            A frozen <see cref="T:ICU4N.Text.Collator"/> is immutable and thread-safe.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.Freeze">
            <summary>
            Freezes the collator.
            </summary>
            <returns>The collator itself.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.CloneAsThawed">
            <summary>
            Provides for the clone operation. Any clone is initially unfrozen.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.IsHiraganaQuaternary">
            <summary>
            Gets or sets the Hiragana Quaternary mode to be on or off. When the Hiragana Quaternary mode is turned on, the collator
            positions Hiragana characters before all non-ignorable characters in <see cref="F:ICU4N.Text.CollationStrength.Quaternary"/> strength. This is to produce a
            correct JIS collation order, distinguishing between Katakana and Hiragana characters.
            <para/>
            This attribute was an implementation detail of the CLDR Japanese tailoring.
            Since ICU 50, this attribute is not settable any more via API functions.
            Since CLDR 25/ICU 53, explicit quaternary relations are used
            to achieve the same Japanese sort order.
            </summary>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.SetHiraganaQuaternaryToDefault"/>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetHiraganaQuaternaryToDefault">
            <summary>
            Gets or sets the Hiragana Quaternary mode to the initial mode set during construction of the RuleBasedCollator. See
            <see cref="P:ICU4N.Text.RuleBasedCollator.IsHiraganaQuaternary"/> for more details.
            <para/>
            This attribute was an implementation detail of the CLDR Japanese tailoring.
            Since ICU 50, this attribute is not settable any more via API functions.
            Since CLDR 25/ICU 53, explicit quaternary relations are used
            to achieve the same Japanese sort order.
            </summary>
            <seealso cref="P:ICU4N.Text.RuleBasedCollator.IsHiraganaQuaternary"/>
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.IsUpperCaseFirst">
            <summary>
            Gets or sets whether uppercase characters sort before lowercase characters or vice versa in strength <see cref="F:ICU4N.Text.CollationStrength.Tertiary"/>. The
            default mode is false, and so lowercase characters sort before uppercase characters. If true, sort uppercase
            characters first.
            </summary>
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.IsLowerCaseFirst">
            <summary>
            Gets or sets the orders of lower-cased characters to sort before uppercased characters in strength <see cref="F:ICU4N.Text.CollationStrength.Tertiary"/>. The
            default mode is false. If true is set, the <see cref="T:ICU4N.Text.RuleBasedCollator"/> will sort lowercased characters before the uppercased 
            ones. Otherwise, if false is set, the <see cref="T:ICU4N.Text.RuleBasedCollator"/> will ignore case preferences.
            </summary>
            <seealso cref="P:ICU4N.Text.RuleBasedCollator.IsUpperCaseFirst"/>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.SetCaseFirstToDefault"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetCaseFirstToDefault">
            <summary>
            Sets the case first mode to the initial mode set during construction of the <see cref="T:ICU4N.Text.RuleBasedCollator"/>. See
            <see cref="P:ICU4N.Text.RuleBasedCollator.IsUpperCaseFirst"/> and <see cref="P:ICU4N.Text.RuleBasedCollator.IsLowerCaseFirst"/> for more details.
            </summary>
            <seealso cref="P:ICU4N.Text.RuleBasedCollator.IsUpperCaseFirst"/>
            <seealso cref="P:ICU4N.Text.RuleBasedCollator.IsLowerCaseFirst"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetAlternateHandlingToDefault">
            <summary>
            Sets the alternate handling mode to the initial mode set during construction of the <see cref="T:ICU4N.Text.RuleBasedCollator"/>. See
            <see cref="P:ICU4N.Text.RuleBasedCollator.IsAlternateHandlingShifted"/> for more details.
            </summary>
            <seealso cref="P:ICU4N.Text.RuleBasedCollator.IsAlternateHandlingShifted"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetCaseLevelToDefault">
            <summary>
            Sets the case level mode to the initial mode set during construction of the <see cref="T:ICU4N.Text.RuleBasedCollator"/>. See
            <seealso cref="P:ICU4N.Text.RuleBasedCollator.IsCaseLevel"/> for more details.
            </summary>
            <seealso cref="P:ICU4N.Text.RuleBasedCollator.IsCaseLevel"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetDecompositionToDefault">
            <summary>
            Sets the decomposition mode to the initial mode set during construction of the <see cref="T:ICU4N.Text.RuleBasedCollator"/>. See
            <see cref="P:ICU4N.Text.RuleBasedCollator.Decomposition"/> for more details.
            </summary>
            <seealso cref="P:ICU4N.Text.RuleBasedCollator.Decomposition"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetFrenchCollationToDefault">
            <summary>
            Sets the French collation mode to the initial mode set during construction of the <see cref="T:ICU4N.Text.RuleBasedCollator"/>. See
            <see cref="P:ICU4N.Text.RuleBasedCollator.IsFrenchCollation"/> for more details.
            </summary>
            <seealso cref="P:ICU4N.Text.RuleBasedCollator.IsFrenchCollation"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetStrengthToDefault">
            <summary>
            Sets the collation strength to the initial mode set during the construction of the <see cref="T:ICU4N.Text.RuleBasedCollator"/>. See
            <see cref="P:ICU4N.Text.RuleBasedCollator.Strength"/> for more details.
            </summary>
            <seealso cref="P:ICU4N.Text.RuleBasedCollator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetNumericCollationToDefault">
            <summary>
            Method to set numeric collation to its default value.
            </summary>
            <seealso cref="P:ICU4N.Text.RuleBasedCollator.IsNumericCollation"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.IsFrenchCollation">
            <summary>
            Gets or sets whether French Collation is enabled. Sets the mode for the direction of <see cref="F:ICU4N.Text.CollationStrength.Secondary"/> 
            weights to be used in French collation. The default value is false,
            which treats <see cref="F:ICU4N.Text.CollationStrength.Secondary"/> weights in the order they appear. If set to true, the <see cref="F:ICU4N.Text.CollationStrength.Secondary"/> weights will be sorted
            backwards. See the section on <a href="http://userguide.icu-project.org/collation/architecture">
            French collation</a> for more information.
            </summary>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.SetFrenchCollationToDefault"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.IsAlternateHandlingShifted">
            <summary>
            Gets or sets whether the handling for <see cref="F:ICU4N.Text.CollationStrength.Quaternary"/> to be either shifted or non-ignorable. See the UCA definition
            on <a href="http://www.unicode.org/unicode/reports/tr10/#Variable_Weighting">Variable Weighting</a>. This
            property will only be effective when <see cref="P:ICU4N.Text.RuleBasedCollator.Strength"/> is set to <see cref="F:ICU4N.Text.CollationStrength.Quaternary"/>. The default value for this mode is false,
            corresponding to the NON_IGNORABLE mode in UCA. In the NON_IGNORABLE mode, the RuleBasedCollator treats all
            the code points with non-ignorable primary weights in the same way. If the mode is set to true, the behavior
            corresponds to SHIFTED defined in UCA, this causes code points with <see cref="F:ICU4N.Text.CollationStrength.Primary"/> orders that are equal or below the
            variable top value to be ignored in <see cref="F:ICU4N.Text.CollationStrength.Primary"/> order and moved to the <see cref="F:ICU4N.Text.CollationStrength.Quaternary"/> order.
            </summary>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.SetAlternateHandlingToDefault"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.IsCaseLevel">
            <summary>
            Gets or sets case level. When case level is set to true, an additional weight is formed between the 
            <see cref="F:ICU4N.Text.CollationStrength.Secondary"/> and <see cref="F:ICU4N.Text.CollationStrength.Tertiary"/> weight, known
            as the case level. The case level is used to distinguish large and small Japanese Kana characters. Case level
            could also be used in other situations. For example to distinguish certain Pinyin characters. The default value
            is false, which means the case level is not generated. The contents of the case level are affected by the case
            first mode. A simple way to ignore accent differences in a string is to set the strength to <see cref="F:ICU4N.Text.CollationStrength.Primary"/> and enable
            case level.
            <para/>
            See the section on <a href="http://userguide.icu-project.org/collation/architecture">case
            level</a> for more information.
            </summary>
            <stable>ICU 2.8</stable>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.SetCaseLevelToDefault"/>
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.Decomposition">
            <summary>
            Gets or sets the decomposition mode of this Collator. The decomposition mode
            determines how Unicode composed characters are handled.
            <para/>
            Setting this property with <see cref="F:ICU4N.Text.NormalizationMode.CanonicalDecomposition"/> allows the
            <see cref="T:ICU4N.Text.Collator"/> to handle un-normalized text properly, producing the
            same results as if the text were normalized. If
            <see cref="F:ICU4N.Text.NormalizationMode.NoDecomposition"/> is set, it is the user's responsibility to
            ensure that all text is already in the appropriate form before
            a comparison or before getting a <see cref="T:ICU4N.Text.CollationKey"/>. Adjusting
            decomposition mode allows the user to select between faster and
            more complete collation behavior.
            <para/>
            Since a great many of the world's languages do not require
            text normalization, most locales set <see cref="F:ICU4N.Text.NormalizationMode.NoDecomposition"/> as the
            default decomposition mode.
            <para/>
            The default decompositon mode for the <see cref="T:ICU4N.Text.Collator"/> is <see cref="F:ICU4N.Text.NormalizationMode.NoDecomposition"/>,
            unless specified otherwise by the locale used
            to create the <see cref="T:ICU4N.Text.Collator"/>.
            <para/>
            See the <see cref="T:ICU4N.Text.Collator"/> documentation for more details.
            </summary>
            <seealso cref="F:ICU4N.Text.NormalizationMode.NoDecomposition"/>
            <seealso cref="F:ICU4N.Text.NormalizationMode.CanonicalDecomposition"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.Strength">
            <summary>
            Gets or sets this Collator's strength attribute. The strength attribute determines the minimum level of difference
            considered significant during comparison.
            <para/>
            See the <see cref="T:ICU4N.Text.Collator"/> documentation for an example of use.
            </summary>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.SetStrengthToDefault"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Primary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Secondary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Tertiary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Quaternary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Identical"/>
            <exception cref="T:System.ArgumentException">If the new strength value is not one of <see cref="F:ICU4N.Text.CollationStrength.Primary"/>, <see cref="F:ICU4N.Text.CollationStrength.Secondary"/>, 
            <see cref="F:ICU4N.Text.CollationStrength.Tertiary"/>, <see cref="F:ICU4N.Text.CollationStrength.Quaternary"/> or <see cref="F:ICU4N.Text.CollationStrength.Identical"/>.</exception>
            <stable>ICU 2.8</stable>
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.MaxVariable">
            <summary>
            <icu/> Gets or sets the maximum reordering group whose characters are affected by
            the alternate handling behavior.
            <para/>
            Setter will set the variable top to the top of the specified reordering group.
            The variable top determines the highest-sorting character
            which is affected by the alternate handling behavior.
            If that attribute is set to NON_IGNORABLE, then the variable top has no effect.
            <para/>
            Set to one of <see cref="F:ICU4N.Text.ReorderCodes.Space"/>, <see cref="F:ICU4N.Text.ReorderCodes.Punctuation"/>,
            <see cref="F:ICU4N.Text.ReorderCodes.Symbol"/>, <see cref="F:ICU4N.Text.ReorderCodes.Currency"/>;
            or <see cref="F:ICU4N.Text.ReorderCodes.Default"/> to restore the default max variable group.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetVariableTop(System.String)">
            <summary>
            <icu/>Sets the variable top to the primary weight of the specified string.
            <para/>
            Beginning with ICU 53, the variable top is pinned to
            the top of one of the supported reordering groups,
            and it must not be beyond the last of those groups.
            <see cref="P:ICU4N.Text.RuleBasedCollator.MaxVariable"/>.
            </summary>
            <param name="varTop">One or more (if contraction) characters to which the variable top should be set.</param>
            <returns>Top primary weight.</returns>
            <exception cref="T:System.ArgumentException">thrown if varTop argument is not a valid variable top element. A variable top element is
            invalid when
            <list type="bullet">
                <item>
                    <description>It is a contraction that does not exist in the <see cref="T:ICU4N.Impl.Coll.Collation"/> order</description>
                </item>
                <item>
                    <description>The variable top is beyond the last reordering group supported by <see cref="P:ICU4N.Text.RuleBasedCollator.MaxVariable"/>.</description>
                </item>
                <item>
                    <description>When the <paramref name="varTop"/> argument is null or zero in length.</description>
                </item>
            </list>
            </exception>
            <seealso cref="P:ICU4N.Text.RuleBasedCollator.VariableTop"/>
            <seealso cref="P:ICU4N.Text.RuleBasedCollator.IsAlternateHandlingShifted"/>
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.VariableTop">
            <summary>
            <icu/>Gets or sets the variable top value of a Collator.
            <para/>
            Beginning with ICU 53, the variable top is pinned to
            the top of one of the supported reordering groups,
            and it must not be beyond the last of those groups.
            See <see cref="P:ICU4N.Text.RuleBasedCollator.MaxVariable"/>.
            </summary>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.SetVariableTop(System.String)"/>
            <seealso cref="P:ICU4N.Text.RuleBasedCollator.MaxVariable"/>
            <stable>ICU 2.6</stable>
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.IsNumericCollation">
            <summary>
            <icu/>Gets or sets the numeric collation value. When numeric collation is turned on, this Collator generates a
            collation key for the numeric value of substrings of digits.
            <para/>
            This is a way to get '100' to sort AFTER '2'. Note that the longest
            digit substring that can be treated as a single unit is
            254 digits (not counting leading zeros). If a digit substring is
            longer than that, the digits beyond the limit will be treated as a
            separate digit substring.
            <para/>
            A "digit" in this sense is a code point with General_Category=Nd,
            which does not include circled numbers, roman numerals, etc.
            Only a contiguous digit substring is considered, that is,
            non-negative integers without separators.
            There is no support for plus/minus signs, decimals, exponents, etc.
            </summary>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.SetNumericCollationToDefault"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetReorderCodes(System.Int32[])">
            <summary>
            Sets the reordering codes for this collator.
            Collation reordering allows scripts and some other groups of characters
            to be moved relative to each other. This reordering is done on top of
            the DUCET/CLDR standard collation order. Reordering can specify groups to be placed
            at the start and/or the end of the collation order. These groups are specified using
            <see cref="T:ICU4N.Globalization.UScript"/> codes and <see cref="T:ICU4N.Text.ReorderCodes"/> entries.
            <para/>
            By default, reordering codes specified for the start of the order are placed in the
            order given after several special non-script blocks. These special groups of characters
            are space, punctuation, symbol, currency, and digit. These special groups are represented with
            <see cref="T:ICU4N.Text.ReorderCodes"/> entries. Script groups can be intermingled with
            these special non-script groups if those special groups are explicitly specified in the reordering.
            <para/>
            The special code <see cref="F:ICU4N.Text.ReorderCodes.Others"/>
            stands for any script that is not explicitly
            mentioned in the list of reordering codes given. Anything that is after <see cref="F:ICU4N.Text.ReorderCodes.Others"/>
            will go at the very end of the reordering in the order given.
            <para/>
            The special reorder code <see cref="F:ICU4N.Text.ReorderCodes.Default"/>
            will reset the reordering for this collator
            to the default for this collator. The default reordering may be the DUCET/CLDR order or may be a reordering that
            was specified when this collator was created from resource data or from rules. The
            DEFAULT code <b>must</b> be the sole code supplied when it is used.
            If not, then an <see cref="T:System.ArgumentException"/> will be thrown.
            <para/>
            The special reorder code <see cref="F:ICU4N.Text.ReorderCodes.None"/>
            will remove any reordering for this collator.
            The result of setting no reordering will be to have the DUCET/CLDR ordering used. The
            <see cref="F:ICU4N.Text.ReorderCodes.None"/> code <b>must</b> be the sole code supplied when it is used.
            </summary>
            <param name="order">
            The reordering codes to apply to this collator; if this is null or an empty array
            then this clears any existing reordering.
            </param>
            <exception cref="T:System.ArgumentException">If the reordering codes are malformed in any way (e.g. duplicates, multiple reset codes, overlapping equivalent scripts).</exception>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.GetReorderCodes"/>
            <seealso cref="M:ICU4N.Text.Collator.GetEquivalentReorderCodes(System.Int32)"/>
            <seealso cref="T:ICU4N.Text.ReorderCodes"/>
            <seealso cref="T:ICU4N.Globalization.UScript"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetRules">
            <summary>
            Gets the collation tailoring rules for this <see cref="T:ICU4N.Text.RuleBasedCollator"/>.
            Equivalent to string <c>GetRules(false)</c>.
            </summary>
            <returns>The collation tailoring rules.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetRules(System.Boolean)">
            <summary>
            Returns current rules.
            The <paramref name="fullrules"/> argument defines whether full rules (root collation + tailored) rules are returned
            or just the tailoring.
            <para/>
            The root collation rules are an <i>approximation</i> of the root collator's sort order.
            They are almost never used or useful at runtime and can be removed from the data.
            See <a href="http://userguide.icu-project.org/collation/customization#TOC-Building-on-Existing-Locales">User Guide:
            Collation Customization, Building on Existing Locales</a>
            <para/>
            <see cref="M:ICU4N.Text.RuleBasedCollator.GetRules"/> should normally be used instead.
            </summary>
            <param name="fullrules"><c>true</c> if the rules that defines the full set of collation order is required, otherwise <c>false</c> for
            returning only the tailored rules.</param>
            <returns>The current rules that define this <see cref="T:ICU4N.Text.Collator"/>.</returns>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.GetRules"/>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.GetRules(System.Boolean)"/>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetTailoredSet">
            <summary>
            Get a <see cref="T:ICU4N.Text.UnicodeSet"/> that contains all the characters and sequences tailored in this collator.
            </summary>
            <returns>A pointer to a <see cref="T:ICU4N.Text.UnicodeSet"/> object containing all the code points and sequences that may sort differently
            than in the root collator.</returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetContractionsAndExpansions(ICU4N.Text.UnicodeSet,ICU4N.Text.UnicodeSet,System.Boolean)">
            <summary>
            Gets unicode sets containing contractions and/or expansions of a collator.
            </summary>
            <param name="contractions">If not null, set to contain contractions.</param>
            <param name="expansions">If not null, set to contain expansions.</param>
            <param name="addPrefixes">Add the prefix contextual elements to contractions.</param>
            <exception cref="T:System.Exception">Throws an exception if any errors occurs.</exception>
            <stable>ICU 3.4</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.InternalAddContractions(System.Int32,ICU4N.Text.UnicodeSet)">
            <summary>
            Adds the contractions that start with character <paramref name="c"/> to the <paramref name="set"/>.
            Ignores prefixes. Used by <see cref="T:ICU4N.Text.AlphabeticIndex`1"/>.
            </summary>
            <param name="c"></param>
            <param name="set"></param>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetCollationKey(System.String)">
            <summary>
            Get a <see cref="T:ICU4N.Text.CollationKey"/> for the argument <see cref="T:System.String"/> <paramref name="source"/> from this <see cref="T:ICU4N.Text.RuleBasedCollator"/>.
            <para/>
            General recommendation: <br/>
            If comparison are to be done to the same <see cref="T:System.String"/> multiple times, it would be more efficient to generate
            <see cref="T:ICU4N.Text.CollationKey"/>s for the <see cref="T:System.String"/> and use <see cref="M:ICU4N.Text.CollationKey.CompareTo(ICU4N.Text.CollationKey)"/> for the comparisons. If the each
            <see cref="T:System.String"/>s are compared to only once, using the method <see cref="M:ICU4N.Text.RuleBasedCollator.Compare(System.String,System.String)"/> will have a better
            performance.
            <para/>
            See <see cref="T:ICU4N.Text.RuleBasedCollator"/> for an explanation about <see cref="T:ICU4N.Text.CollationKey"/>s.
            </summary>
            <param name="source">The text <see cref="T:System.String"/> to be transformed into a collation key.</param>
            <returns>The <see cref="T:ICU4N.Text.CollationKey"/> for the given <see cref="T:System.String"/> based on this <see cref="T:ICU4N.Text.RuleBasedCollator"/>'s collation rules. If the source
            <see cref="T:System.String"/> is null, a null <see cref="T:ICU4N.Text.CollationKey"/> is returned.</returns>
            <seealso cref="T:ICU4N.Text.CollationKey"/>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.Compare(System.String,System.String)"/>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.GetRawCollationKey(System.String,ICU4N.Text.RawCollationKey)"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetRawCollationKey(System.String,ICU4N.Text.RawCollationKey)">
            <summary>
            Gets the simpler form of a <see cref="T:ICU4N.Text.CollationKey"/> for the <see cref="T:System.String"/> <paramref name="source"/> following the rules of this <see cref="T:ICU4N.Text.Collator"/> and stores the
            result into the user provided argument key. If key has a internal byte array of length that's too small for the
            result, the internal byte array will be grown to the exact required size.
            </summary>
            <param name="source">The text <see cref="T:System.String"/> to be transformed into a <see cref="T:ICU4N.Text.RawCollationKey"/>.</param>
            <param name="key">Output <see cref="T:ICU4N.Text.RawCollationKey"/> to store results.</param>
            <returns>If key is null, a new instance of <see cref="T:ICU4N.Text.RawCollationKey"/> will be created and returned, otherwise the user
            provided key will be returned.</returns>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.GetCollationKey(System.String)"/>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.GetCollationKey(System.String,ICU4N.Text.RuleBasedCollator.CollationBuffer)"/>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.Compare(System.String,System.String)"/>
            <seealso cref="T:ICU4N.Text.RawCollationKey"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.InternalGetCEs(J2N.Text.ICharSequence)">
            <summary>
            Returns the CEs for the string.
            </summary>
            <param name="str">The string.</param>
            <internal>For tests &amp; tools.</internal>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetReorderCodes">
            <summary>
            Retrieves the reordering codes for this collator.
            These reordering codes are a combination of <see cref="T:ICU4N.Globalization.UScript"/> codes and <see cref="T:ICU4N.Text.ReorderCodes"/>.
            </summary>
            <returns>A copy of the reordering codes for this collator;
            if none are set then returns an empty array.</returns>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.SetReorderCodes(System.Int32[])"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.Equals(System.Object)">
            <summary>
            Compares the equality of two <see cref="T:ICU4N.Text.RuleBasedCollator"/> objects. <see cref="T:ICU4N.Text.RuleBasedCollator"/> objects are equal if they have the same
            collation (sorting &amp; searching) behavior.
            </summary>
            <param name="obj">The <see cref="T:ICU4N.Text.RuleBasedCollator"/> to compare to.</param>
            <returns><c>true</c> if this <see cref="T:ICU4N.Text.RuleBasedCollator"/> has exactly the same collation behavior as <paramref name="obj"/>, <c>false</c> otherwise.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetHashCode">
            <summary>
            Generates a unique hash code for this <see cref="T:ICU4N.Text.RuleBasedCollator"/>.
            </summary>
            <returns>The unique hash code for this <see cref="T:ICU4N.Text.Collator"/>.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.Compare(System.String,System.String)">
            <summary>
            Compares the source text <see cref="T:System.String"/> to the target text <see cref="T:System.String"/> according to the collation rules, strength and
            decomposition mode for this <see cref="T:ICU4N.Text.RuleBasedCollator"/>. Returns an <see cref="T:System.Int32"/> less than, equal to or greater than zero
            depending on whether the source <see cref="T:System.String"/> is less than, equal to or greater than the target <see cref="T:System.String"/>. See the <see cref="T:ICU4N.Text.Collator"/>
            documentation for an example of use.
            <para/>
            General recommendation: <br/>
            If comparison are to be done to the same <see cref="T:System.String"/> multiple times, it would be more efficient to generate
            <see cref="T:ICU4N.Text.CollationKey"/>s for the <see cref="T:System.String"/>s and use <see cref="M:ICU4N.Text.CollationKey.CompareTo(ICU4N.Text.CollationKey)"/> for the comparisons. If speed
            performance is critical and object instantiation is to be reduced, further optimization may be achieved by
            generating a simpler key of the form <see cref="T:ICU4N.Text.RawCollationKey"/> and reusing this <see cref="T:ICU4N.Text.RawCollationKey"/> object with the method
            <see cref="M:ICU4N.Text.RuleBasedCollator.GetRawCollationKey(System.String,ICU4N.Text.RawCollationKey)"/>. Internal byte representation can be directly accessed via <see cref="T:ICU4N.Text.RawCollationKey"/>
            and stored for future use. Like <see cref="T:ICU4N.Text.CollationKey"/>, <see cref="T:ICU4N.Text.RawCollationKey"/> provides a method <see cref="M:ICU4N.Text.RawCollationKey.CompareTo(ICU4N.Util.ByteArrayWrapper)"/> for key
            comparisons. If the each <see cref="T:System.String"/>s are compared to only once, using the method <see cref="M:ICU4N.Text.RuleBasedCollator.Compare(System.String,System.String)"/>
            will have a better performance.
            </summary>
            <param name="source">The source text <see cref="T:System.String"/>.</param>
            <param name="target">The target text <see cref="T:System.String"/>.</param>
            <returns>Returns an integer value. Value is less than zero if source is less than target, value is zero if source
            and target are equal, value is greater than zero if source is greater than target.</returns>
            <seealso cref="T:ICU4N.Text.CollationKey"/>
            <seealso cref="M:ICU4N.Text.RuleBasedCollator.GetCollationKey(System.String)"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="T:ICU4N.Text.RuleBasedCollator.NFDIterator">
            <summary>
            Abstract iterator for identical-level string comparisons.
            Returns FCD code points and handles temporary switching to NFD.
            <para/>
            As with <see cref="T:ICU4N.Impl.Coll.CollationIterator"/>,
            .NET <see cref="T:ICU4N.Text.RuleBasedCollator.NFDIterator"/> instances are partially constructed and cached,
            and completed when reset for use.
            C++ NFDIterator instances are stack-allocated.
            </summary>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.NFDIterator.#ctor">
            <summary>
            Partial constructor, must call <see cref="M:ICU4N.Text.RuleBasedCollator.NFDIterator.Reset"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.NFDIterator.NextCodePoint">
            <summary>
            Returns the next code point from the internal normalization buffer,
            or else the next text code point.
            Returns -1 at the end of the text.
            </summary>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.NFDIterator.NextDecomposedCodePoint(ICU4N.Impl.Normalizer2Impl,System.Int32)">
            <summary>
            
            </summary>
            <param name="nfcImpl"></param>
            <param name="c">The last code point returned by <see cref="M:ICU4N.Text.RuleBasedCollator.NFDIterator.NextCodePoint"/> or <see cref="M:ICU4N.Text.RuleBasedCollator.NFDIterator.NextDecomposedCodePoint(ICU4N.Impl.Normalizer2Impl,System.Int32)"/>.</param>
            <returns>The first code point in <paramref name="c"/>'s decomposition, or <paramref name="c"/> itself if it was decomposed already or if it does not decompose.</returns>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.NFDIterator.NextRawCodePoint">
            <summary>
            Returns the next text code point in FCD order.
            Returns -1 at the end of the text.
            </summary>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.DoCompare(J2N.Text.ICharSequence,J2N.Text.ICharSequence)">
            <summary>
            Compares two <see cref="T:J2N.Text.ICharSequence"/>s.
            </summary>
            <internal/>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.IsUnsafe(System.Int32)">
            <summary>
            Tests whether a character is "unsafe" for use as a collation starting point.
            </summary>
            <param name="c">Code point or code unit.</param>
            <returns><c>true</c> if <paramref name="c"/> is unsafe.</returns>
            <seealso cref="M:ICU4N.Text.CollationElementIterator.SetOffset(System.Int32)"/>
        </member>
        <member name="F:ICU4N.Text.RuleBasedCollator.frozenLock">
            <summary>
            Frozen state of the collator.
            </summary>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetVersion">
            <summary>
            Get the version of this collator object.
            </summary>
            <returns>The version object associated with this collator.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetUCAVersion">
            <summary>
            Get the UCA version of this collator object.
            </summary>
            <returns>The version object associated with this collator.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.ActualCulture">
            <summary>
            <icu/> Gets the locale that was used to create this object, or <c>null</c>.
            <para/>
            Indicates the locale of the resource containing the data. This is always
            at or above the valid locale. If the valid locale does not contain the
            specific data being requested, then the actual locale will be
            above the valid locale. If the object was not constructed from
            locale data, then the valid locale is <c>null</c>.
            <para/>
            This may may differ from the locale requested at the time of
            this object's creation. For example, if an object is created
            for locale <c>en_US_CALIFORNIA</c>, the actual data may be
            drawn from <c>en</c> (the <i>actual</i> locale), and
            <c>en_US</c> may be the most specific locale that exists (the
            <i>valid</i> locale).
            <para/>
            Note: This property will be implemented in ICU 3.0; ICU 2.8
            contains a partial preview implementation. The * <i>actual</i>
            locale is returned correctly, but the <i>valid</i> locale is
            not, in most cases.
            <para/>
            The base class method always returns <see cref="P:ICU4N.Globalization.UCultureInfo.InvariantCulture"/>
            Subclasses should override it if appropriate.
            </summary>
            <seealso cref="T:ICU4N.Globalization.UCultureInfo"/>
            <draft>ICU 60</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.ValidCulture">
            <summary>
            <icu/> Gets the locale that was used to create this object, or <c>null</c>.
            <para/>
            Indicates the most specific locale for which any data exists.
            This is always at or above the requested locale, and at or below
            the actual locale. If the requested locale does not correspond
            to any resource data, then the valid locale will be above the
            requested locale. If the object was not constructed from locale
            data, then the actual locale is <c>null</c>.
            <para/>
            This may may differ from the locale requested at the time of
            this object's creation. For example, if an object is created
            for locale <c>en_US_CALIFORNIA</c>, the actual data may be
            drawn from <c>en</c> (the <i>actual</i> locale), and
            <c>en_US</c> may be the most specific locale that exists (the
            <i>valid</i> locale).
            <para/>
            Note: This property will be implemented in ICU 3.0; ICU 2.8
            contains a partial preview implementation. The * <i>actual</i>
            locale is returned correctly, but the <i>valid</i> locale is
            not, in most cases.
            <para/>
            The base class method always returns <see cref="P:ICU4N.Globalization.UCultureInfo.InvariantCulture"/>
            Subclasses should override it if appropriate.
            </summary>
            <seealso cref="T:ICU4N.Globalization.UCultureInfo"/>
            <draft>ICU 2.8 (retain)</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetCulture(ICU4N.Globalization.UCultureInfo,ICU4N.Globalization.UCultureInfo)">
            <summary>
            Set information about the locales that were used to create this
            object.  If the object was not constructed from locale data,
            both arguments should be set to null.  Otherwise, neither
            should be null.  The actual locale must be at the same level or
            less specific than the valid locale. This method is intended
            for use by factories or other entities that create objects of
            this class.
            </summary>
            <param name="valid">The most specific locale containing any resource data, or <c>null</c>.</param>
            <param name="actual">The locale containing data used to construct this object, or <c>null</c>.</param>
            <seealso cref="T:ICU4N.Globalization.UCultureInfo"/>
        </member>
        <member name="T:ICU4N.Text.SearchIterator">
            <summary>
            <see cref="T:ICU4N.Text.SearchIterator"/> is an abstract base class that provides 
            methods to search for a pattern within a text string. Instances of
            <see cref="T:ICU4N.Text.SearchIterator"/> maintain a current position and scan over the 
            target text, returning the indices the pattern is matched and the length 
            of each match.
            </summary>
            <remarks>
            <see cref="T:ICU4N.Text.SearchIterator"/> defines a protocol for text searching. 
            Subclasses provide concrete implementations of various search algorithms. 
            For example, <see cref="T:ICU4N.Text.StringSearch"/> implements language-sensitive pattern 
            matching based on the comparison rules defined in a 
            <see cref="T:ICU4N.Text.RuleBasedCollator"/> object.
            <para/>
            Other options for searching include using a <see cref="T:ICU4N.Text.BreakIterator"/> to restrict
            the points at which matches are detected.
            <para/>
            <see cref="T:ICU4N.Text.SearchIterator"/> provides an API that is similar to that of
            other text iteration classes such as <see cref="T:ICU4N.Text.BreakIterator"/>. Using 
            this class, it is easy to scan through text looking for all occurrences of 
            a given pattern. The following example uses a <see cref="T:ICU4N.Text.StringSearch"/>
            object to find all instances of "fox" in the target string. Any other 
            subclass of <see cref="T:ICU4N.Text.SearchIterator"/> can be used in an identical 
            manner.
            <code>
            string target = "The quick brown fox jumped over the lazy fox";
            string pattern = "fox";
            SearchIterator iter = new StringSearch(pattern, target);
            for (int pos = iter.First(); pos != SearchIterator.Done; pos = iter.Next())
            {
                Console.WriteLine($"Found match at {pos}, length is {iter.MatchLength}");
            }
            </code>
            </remarks>
            <author>Laura Werner, synwee</author>
            <stable>ICU 2.0</stable>
            <seealso cref="T:ICU4N.Text.BreakIterator"/>
            <seealso cref="T:ICU4N.Text.RuleBasedCollator"/>
        </member>
        <member name="F:ICU4N.Text.SearchIterator.m_breakIterator">
            <summary>
            The <see cref="T:ICU4N.Text.BreakIterator"/> to define the boundaries of a logical match.
            This value can be a null.
            See <see cref="T:ICU4N.Text.SearchIterator"/> for more information.
            </summary>
            <seealso cref="M:ICU4N.Text.SearchIterator.SetBreakIterator(ICU4N.Text.BreakIterator)"/>
            <seealso cref="P:ICU4N.Text.SearchIterator.BreakIterator"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="F:ICU4N.Text.SearchIterator.m_targetText">
            <summary>
            Target text for searching.
            </summary>
            <seealso cref="M:ICU4N.Text.SearchIterator.SetTarget(ICU4N.Support.Text.CharacterIterator)"/>
            <seealso cref="P:ICU4N.Text.SearchIterator.Target"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="F:ICU4N.Text.SearchIterator.m_matchLength">
            <summary>
            Length of the most current match in target text. 
            Value 0 is the default value.
            </summary>
            <seealso cref="P:ICU4N.Text.SearchIterator.MatchLength"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="T:ICU4N.Text.SearchIterator.Search">
            <summary>
            C# port of ICU4C struct USearch (usrchimp.h)
            <para/>
            Note:
            <para/>
            ICU4N already exposed some protected members such as
            <see cref="F:ICU4N.Text.SearchIterator.m_targetText"/>, <see cref="F:ICU4N.Text.SearchIterator.m_breakIterator"/> and <see cref="F:ICU4N.Text.SearchIterator.m_matchLength"/> as a part of stable
            APIs. In ICU4C, they are exposed through USearch struct, 
            although USearch struct itself is internal API.
            <para/>
            This class was created for making ICU4N code parallel to
            ICU4C implementation. ICU4N implementation access member
            fields like C struct (e.g. search_.isOverlap_) mostly, except
            fields already exposed as protected member (e.g. search_.text()).
            </summary>
        </member>
        <member name="F:ICU4N.Text.SearchIterator.Search.isOverlap_">
            <summary>
            Flag to indicate if overlapping search is to be done.
            E.g. looking for "aa" in "aaa" will yield matches at offset 0 and 1.
            </summary>
        </member>
        <member name="F:ICU4N.Text.SearchIterator.Search.isForwardSearching_">
            <summary>
            Flag indicates if we are doing a forwards search
            </summary>
        </member>
        <member name="F:ICU4N.Text.SearchIterator.Search.reset_">
            <summary>
            Flag indicates if we are at the start of a string search.
            This indicates that we are in forward search and at the start of m_text.
            </summary>
        </member>
        <member name="F:ICU4N.Text.SearchIterator.Done">
            <summary>
            <see cref="F:ICU4N.Text.SearchIterator.Done"/> is returne by <see cref="M:ICU4N.Text.SearchIterator.Previous"/> and <see cref="M:ICU4N.Text.SearchIterator.Next"/> after all valid matches have 
            been returned, and by <see cref="M:ICU4N.Text.SearchIterator.First"/> and <see cref="M:ICU4N.Text.SearchIterator.Last"/> if there are no matches at all.
            </summary>
            <seealso cref="M:ICU4N.Text.SearchIterator.Previous"/>
            <seealso cref="M:ICU4N.Text.SearchIterator.Next"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.SearchIterator.SetIndex(System.Int32)">
            <summary>
            Sets the position in the target text at which the next search will start.
            This method clears any previous match.
            </summary>
            <param name="position">Position from which to start the next search.</param>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if argument position is out of the target text range.</exception>
            <see cref="P:ICU4N.Text.SearchIterator.Index"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.SearchIterator.SetBreakIterator(ICU4N.Text.BreakIterator)">
            <summary>
            Set the <see cref="T:ICU4N.Text.BreakIterator"/> that will be used to restrict the points
            at which matches are detected.
            </summary>
            <param name="breakIterator">
            A <see cref="T:ICU4N.Text.BreakIterator"/> that will be used to restrict the 
            points at which matches are detected. If a match is 
            found, but the match's start or end index is not a 
            boundary as determined by the <see cref="T:ICU4N.Text.BreakIterator"/>,
            the match will be rejected and another will be searched 
            for. If this parameter is <c>null</c>, no break
            detection is attempted.
            </param>
            <seealso cref="T:ICU4N.Text.BreakIterator"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.SearchIterator.SetTarget(ICU4N.Support.Text.CharacterIterator)">
            <summary>
            Set the target text to be searched. Text iteration will then begin at 
            the start of the text string. This method is useful if you want to 
            reuse an iterator to search within a different body of text.
            </summary>
            <param name="text">New text iterator to look for match.</param>
            <exception cref="T:System.ArgumentException">Thrown when text is null or has 0 length.</exception>
            <see cref="P:ICU4N.Text.SearchIterator.Target"/>
            <stable>ICU 2.4</stable>
        </member>
        <member name="P:ICU4N.Text.SearchIterator.MatchStart">
            <summary>
            Gets the index to the match in the text string that was searched.
            This call returns a valid result only after a successful call to 
            <see cref="M:ICU4N.Text.SearchIterator.First"/>, <see cref="M:ICU4N.Text.SearchIterator.Next"/>, <see cref="M:ICU4N.Text.SearchIterator.Previous"/>, or <see cref="M:ICU4N.Text.SearchIterator.Last"/>.
            Just after construction, or after a searching method returns 
            <see cref="F:ICU4N.Text.SearchIterator.Done"/>, this property will return <see cref="F:ICU4N.Text.SearchIterator.Done"/>.
            <para/>
            Use <see cref="P:ICU4N.Text.SearchIterator.MatchLength"/> to get the matched string length.
            </summary>
            <seealso cref="M:ICU4N.Text.SearchIterator.First"/>
            <seealso cref="M:ICU4N.Text.SearchIterator.Next"/>
            <seealso cref="M:ICU4N.Text.SearchIterator.Previous"/>
            <seealso cref="M:ICU4N.Text.SearchIterator.Last"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.SearchIterator.Index">
            <summary>
            Gets the current index in the text being searched.
            If the iteration has gone past the end of the text
            (or past the beginning for a backwards search), <see cref="F:ICU4N.Text.SearchIterator.Done"/>
            is returned.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="P:ICU4N.Text.SearchIterator.MatchLength">
            <summary>
            Gets or sets the length of text in the string which matches the search 
            pattern. This call returns a valid result only after a successful call 
            to <see cref="M:ICU4N.Text.SearchIterator.First"/>, <see cref="M:ICU4N.Text.SearchIterator.Next"/>, <see cref="M:ICU4N.Text.SearchIterator.Previous"/>, or <see cref="M:ICU4N.Text.SearchIterator.Last"/>.
            Just after construction, or after a searching method returns 
            <see cref="F:ICU4N.Text.SearchIterator.Done"/>, this property will return 0.
            <para/>
            Returns the length of the match in the target text, or 0 if there
            is no match currently.
            <para/>
            Subclass' <see cref="M:ICU4N.Text.SearchIterator.HandleNext(System.Int32)"/> and <see cref="M:ICU4N.Text.SearchIterator.HandlePrevious(System.Int32)"/> methods should set this
            after they find a match in the target text.
            </summary>
            <seealso cref="M:ICU4N.Text.SearchIterator.First"/>
            <seealso cref="M:ICU4N.Text.SearchIterator.Next"/>
            <seealso cref="M:ICU4N.Text.SearchIterator.Previous"/>
            <seealso cref="M:ICU4N.Text.SearchIterator.Last"/>
            <seealso cref="M:ICU4N.Text.SearchIterator.HandleNext(System.Int32)"/>
            <seealso cref="M:ICU4N.Text.SearchIterator.HandlePrevious(System.Int32)"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.SearchIterator.BreakIterator">
            <summary>
            Returns the <see cref="T:ICU4N.Text.BreakIterator"/> that is used to restrict the indexes at which 
            matches are detected. This will be the same object that was passed to 
            the constructor or to <see cref="M:ICU4N.Text.SearchIterator.SetBreakIterator(ICU4N.Text.BreakIterator)"/>.
            If the <see cref="T:ICU4N.Text.BreakIterator"/> has not been set, <c>null</c> will be returned.
            <see cref="M:ICU4N.Text.SearchIterator.SetBreakIterator(ICU4N.Text.BreakIterator)"/> for more information.
            </summary>
            <seealso cref="M:ICU4N.Text.SearchIterator.SetBreakIterator(ICU4N.Text.BreakIterator)"/>
            <seealso cref="T:ICU4N.Text.BreakIterator"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.SearchIterator.Target">
            <summary>
            Gets the string text to be searched.
            </summary>
            <stable>ICU 2.0</stable>
            <seealso cref="M:ICU4N.Text.SearchIterator.SetTarget(ICU4N.Support.Text.CharacterIterator)"/>
        </member>
        <member name="M:ICU4N.Text.SearchIterator.GetMatchedText">
            <summary>
            Returns the text that was matched by the most recent call to 
            <see cref="M:ICU4N.Text.SearchIterator.First"/>, <see cref="M:ICU4N.Text.SearchIterator.Next"/>, <see cref="M:ICU4N.Text.SearchIterator.Previous"/>, or <see cref="M:ICU4N.Text.SearchIterator.Last"/>.
            If the iterator is not pointing at a valid match (e.g. just after 
            construction or after <see cref="F:ICU4N.Text.SearchIterator.Done"/> has been returned, 
            returns an empty string.
            </summary>
            <returns>The substring in the target test of the most recent match,
            or null if there is no match currently.</returns>
            <seealso cref="M:ICU4N.Text.SearchIterator.First"/>
            <seealso cref="M:ICU4N.Text.SearchIterator.Next"/>
            <seealso cref="M:ICU4N.Text.SearchIterator.Previous"/>
            <seealso cref="M:ICU4N.Text.SearchIterator.Last"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.SearchIterator.Next">
            <summary>
            Returns the index of the next point at which the text matches the
            search pattern, starting from the current position
            The iterator is adjusted so that its current index (as returned by 
            <see cref="P:ICU4N.Text.SearchIterator.Index"/>) is the match position if one was found.
            If a match is not found, <see cref="F:ICU4N.Text.SearchIterator.Done"/> will be returned and
            the iterator will be adjusted to a position after the end of the text
            string.
            </summary>
            <returns>The index of the next match after the current position,
            or <see cref="F:ICU4N.Text.SearchIterator.Done"/> if there are no more matches.</returns>
            <seealso cref="P:ICU4N.Text.SearchIterator.Index"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.SearchIterator.Previous">
            <summary>
            Returns the index of the previous point at which the string text 
            matches the search pattern, starting at the current position.
            The iterator is adjusted so that its current index (as returned by 
            <see cref="P:ICU4N.Text.SearchIterator.Index"/>) is the match position if one was found.
            If a match is not found, <see cref="F:ICU4N.Text.SearchIterator.Done"/> will be returned and
            the iterator will be adjusted to the index <see cref="F:ICU4N.Text.SearchIterator.Done"/>.
            </summary>
            <returns>The index of the previous match before the current position,
            or <see cref="F:ICU4N.Text.SearchIterator.Done"/> if there are no more matches.</returns>
            <seealso cref="P:ICU4N.Text.SearchIterator.Index"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.SearchIterator.IsOverlapping">
            <summary>
            Gets or sets whether overlapping matches are returned. See <see cref="T:ICU4N.Text.SearchIterator"/>
            for more information about overlapping matches.
            <para/>
            The default setting of this property is false.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.SearchIterator.Reset">
            <summary>
            Resets the iteration.
            Search will begin at the start of the text string if a forward
            iteration is initiated before a backwards iteration. Otherwise if a
            backwards iteration is initiated before a forwards iteration, the
            search will begin at the end of the text string.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.SearchIterator.First">
            <summary>
            Returns the first index at which the string text matches the search 
            pattern. The iterator is adjusted so that its current index (as
            returned by <see cref="P:ICU4N.Text.SearchIterator.Index"/>) is the match position if one 
            was found.
            If a match is not found, <see cref="F:ICU4N.Text.SearchIterator.Done"/> will be returned and
            the iterator will be adjusted to the index <see cref="F:ICU4N.Text.SearchIterator.Done"/>.
            </summary>
            <returns>The character index of the first match, or 
            <see cref="F:ICU4N.Text.SearchIterator.Done"/> if there are no matches.</returns>
            <seealso cref="P:ICU4N.Text.SearchIterator.Index"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.SearchIterator.Following(System.Int32)">
            <summary>
            Returns the first index equal or greater than <paramref name="position"/> at which the
            string text matches the search pattern. The iterator is adjusted so 
            that its current index (as returned by <see cref="P:ICU4N.Text.SearchIterator.Index"/>) is the 
            match position if one was found.
            If a match is not found, <see cref="F:ICU4N.Text.SearchIterator.Done"/> will be returned and the
            iterator will be adjusted to the index <see cref="F:ICU4N.Text.SearchIterator.Done"/>.
            </summary>
            <param name="position">Where search if to start from.</param>
            <returns>The character index of the first match following
            <paramref name="position"/>, or <see cref="F:ICU4N.Text.SearchIterator.Done"/> if there are no matches.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If position is less than or greater
            than the text range for searching.</exception>
            <seealso cref="P:ICU4N.Text.SearchIterator.Index"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.SearchIterator.Last">
            <summary>
            Returns the last index in the target text at which it matches the
            search pattern. The iterator is adjusted so that its current index
            (as returned by <see cref="P:ICU4N.Text.SearchIterator.Index"/>) is the match position if one was
            found.
            If a match is not found, <see cref="F:ICU4N.Text.SearchIterator.Done"/> will be returned and
            the iterator will be adjusted to the index <see cref="F:ICU4N.Text.SearchIterator.Done"/>.
            </summary>
            <returns>The index of the first match, or <see cref="F:ICU4N.Text.SearchIterator.Done"/> if there are no matches.</returns>
            <seealso cref="P:ICU4N.Text.SearchIterator.Index"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.SearchIterator.Preceding(System.Int32)">
            <summary>
            Returns the first index less than <paramref name="position"/> at which the string 
            text matches the search pattern. The iterator is adjusted so that its 
            current index (as returned by <see cref="P:ICU4N.Text.SearchIterator.Index"/>) is the match 
            position if one was found. If a match is not found,
            <see cref="F:ICU4N.Text.SearchIterator.Done"/> will be returned and the iterator will be 
            adjusted to the index <see cref="F:ICU4N.Text.SearchIterator.Done"/>.
            <para/>
            When the overlapping option (<see cref="P:ICU4N.Text.SearchIterator.IsOverlapping"/>) is off, the last index of the
            result match is always less than <paramref name="position"/>.
            When the overlapping option is on, the result match may span across
            <paramref name="position"/>.
            </summary>
            <param name="position">Where search is to start from.</param>
            <returns>The character index of the first match preceding 
            <paramref name="position"/>, or <see cref="F:ICU4N.Text.SearchIterator.Done"/> if there are no matches.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If position is less than or greater than the text range for searching.</exception>
            <seealso cref="P:ICU4N.Text.SearchIterator.Index"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.SearchIterator.#ctor(ICU4N.Support.Text.CharacterIterator,ICU4N.Text.BreakIterator)">
            <summary>
            Protected constructor for use by subclasses.
            <para/>
            Initializes the iterator with the argument target text for searching 
            and sets the <see cref="T:ICU4N.Text.BreakIterator"/>.
            See <see cref="T:ICU4N.Text.SearchIterator"/> for more details on the use of the target text
            and <see cref="T:ICU4N.Text.BreakIterator"/>.
            </summary>
            <param name="target">The target text to be searched.</param>
            <param name="breaker">A <see cref="T:ICU4N.Text.BreakIterator"/> that is used to determine the 
            boundaries of a logical match. This argument can be null.</param>
            <exception cref="T:System.ArgumentException">Thrown when argument target is null, or of length 0.</exception>
            <seealso cref="T:ICU4N.Text.BreakIterator"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.SearchIterator.HandleNext(System.Int32)">
            <summary>
            Abstract method which subclasses override to provide the mechanism
            for finding the next match in the target text. This allows different
            subclasses to provide different search algorithms.
            <para/>
            If a match is found, the implementation should return the index at
            which the match starts and should set
            <see cref="P:ICU4N.Text.SearchIterator.MatchLength"/> with the number of characters 
            in the target text that make up the match. If no match is found, the 
            method should return <see cref="F:ICU4N.Text.SearchIterator.Done"/>.
            </summary>
            <param name="start">The index in the target text at which the search 
            should start.</param>
            <returns>Index at which the match starts, else if match is not found
            <see cref="F:ICU4N.Text.SearchIterator.Done"/> is returned.</returns>
            <seealso cref="P:ICU4N.Text.SearchIterator.MatchLength"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.SearchIterator.HandlePrevious(System.Int32)">
            <summary>
            Abstract method which subclasses override to provide the mechanism for
            finding the previous match in the target text. This allows different
            subclasses to provide different search algorithms.
            <para/>
            If a match is found, the implementation should return the index at
            which the match starts and should set 
            <see cref="P:ICU4N.Text.SearchIterator.MatchLength"/> with the number of characters 
            in the target text that make up the match. If no match is found, the 
            method should return <see cref="F:ICU4N.Text.SearchIterator.Done"/>.
            </summary>
            <param name="startAt">The index in the target text at which the search
            should start.</param>
            <returns>Index at which the match starts, else if match is not found 
            <see cref="F:ICU4N.Text.SearchIterator.Done"/> is returned.</returns>
            <seealso cref="P:ICU4N.Text.SearchIterator.MatchLength"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.SearchIterator.SetMatchNotFound">
            <summary>
            </summary>
            <internal/>
        </member>
        <member name="P:ICU4N.Text.SearchIterator.ElementComparisonType">
            <summary>
            Gets or sets the collation element comparison type.
            <para/>
            The default comparison type is <see cref="F:ICU4N.Text.ElementComparisonType.StandardElementComparison"/>.
            </summary>
            <seealso cref="T:ICU4N.Text.ElementComparisonType"/>
            <stable>ICU 53</stable>
        </member>
        <member name="T:ICU4N.Text.ElementComparisonType">
            <summary>
            Option to control how collation elements are compared.
            The default value will be <see cref="F:ICU4N.Text.ElementComparisonType.StandardElementComparison"/>.
            <para/>
            <see cref="F:ICU4N.Text.ElementComparisonType.PatternBaseWeightIsWildcard"/> supports "asymmetric search" as described in
            <a href="http://www.unicode.org/reports/tr10/#Asymmetric_Search">
            UTS #10 Unicode Collation Algorithm</a>, while <see cref="F:ICU4N.Text.ElementComparisonType.AnyBaseWeightIsWildcard"/>
            supports a related option in which "unmarked" characters in either the
            pattern or the searched text are treated as wildcards that match marked or
            unmarked versions of the same character.
            </summary>
            <seealso cref="P:ICU4N.Text.SearchIterator.ElementComparisonType"/>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.ElementComparisonType.StandardElementComparison">
            <summary>
            Standard collation element comparison at the specified collator strength.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.ElementComparisonType.PatternBaseWeightIsWildcard">
            <summary>
            Collation element comparison is modified to effectively provide behavior
            between the specified strength and strength - 1.
            <para/>
            Collation elements in the pattern that have the base weight for the specified
            strength are treated as "wildcards" that match an element with any other
            weight at that collation level in the searched text. For example, with a
            secondary-strength English collator, a plain 'e' in the pattern will match
            a plain e or an e with any diacritic in the searched text, but an e with
            diacritic in the pattern will only match an e with the same diacritic in
            the searched text.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="F:ICU4N.Text.ElementComparisonType.AnyBaseWeightIsWildcard">
            <summary>
            Collation element comparison is modified to effectively provide behavior
            between the specified strength and strength - 1.
            <para/>
            Collation elements in either the pattern or the searched text that have the
            base weight for the specified strength are treated as "wildcards" that match
            an element with any other weight at that collation level. For example, with
            a secondary-strength English collator, a plain 'e' in the pattern will match
            a plain e or an e with any diacritic in the searched text, but an e with
            diacritic in the pattern will only match an e with the same diacritic or a
            plain e in the searched text.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="T:ICU4N.Text.StringSearch">
            <summary>
            <see cref="T:ICU4N.Text.StringSearch"/> is a <see cref="T:ICU4N.Text.SearchIterator"/> that provides
            language-sensitive text searching based on the comparison rules defined
            in a <see cref="T:ICU4N.Text.RuleBasedCollator"/> object.
            <see cref="T:ICU4N.Text.StringSearch"/> ensures that language eccentricity can be
            handled, e.g. for the German collator, characters &#223; and SS will be matched
            if case is chosen to be ignored.
            See the <a href="http://source.icu-project.org/repos/icu/icuhtml/trunk/design/collation/ICU_collation_design.htm">
            "ICU Collation Design Document"</a> for more information.
            <para/>
            There are 2 match options for selection:<br/>
            Let S' be the sub-string of a text string S between the offsets start and
            end [start, end].
            <br/>
            A pattern string P matches a text string S at the offsets [start, end]
            if
            <list type="table">
                <item>
                    <term>option 1</term>
                    <term>Some canonical equivalent of P matches some canonical equivalent
                    of S'</term>
                </item>
                <item>
                    <term>option 2</term>
                    <term>P matches S' and if P starts or ends with a combining mark,
                    there exists no non-ignorable combining mark before or after S?
                    in S respectively.</term>
                </item>
            </list>
            Option 2. is the default.
            <para/>
            This search has APIs similar to that of other text iteration mechanisms
            such as the break iterators in <see cref="T:ICU4N.Text.BreakIterator"/>. Using these
            APIs, it is easy to scan through text looking for all occurrences of
            a given pattern. This search iterator allows changing of direction by
            calling a <see cref="M:ICU4N.Text.StringSearch.Reset"/> followed by a <see cref="M:ICU4N.Text.SearchIterator.Next"/> or <see cref="M:ICU4N.Text.SearchIterator.Previous"/>.
            Though a direction change can occur without calling <see cref="M:ICU4N.Text.StringSearch.Reset"/> first,
            this operation comes with some speed penalty.
            Match results in the forward direction will match the result matches in
            the backwards direction in the reverse order.
            <para/>
            <see cref="T:ICU4N.Text.SearchIterator"/> provides APIs to specify the starting position
            within the text string to be searched, e.g. <see cref="M:ICU4N.Text.SearchIterator.SetIndex(System.Int32)"/>,
            <see cref="M:ICU4N.Text.SearchIterator.Preceding(System.Int32)"/> and <see cref="M:ICU4N.Text.SearchIterator.Following(System.Int32)"/>.
            Since the starting position will be set as it is specified, please take note that
            there are some danger points at which the search may render incorrect
            results:
            <list type="bullet">
                <item>
                    <description>
                        In the midst of a substring that requires normalization.
                    </description>
                </item>
                <item>
                    <description>
                        If the following match is to be found, the position should not be the
                        second character which requires swapping with the preceding
                        character. Vice versa, if the preceding match is to be found, the
                        position to search from should not be the first character which
                        requires swapping with the next character. E.g certain Thai and
                        Lao characters require swapping.
                    </description>
                </item>
                <item>
                    <description>
                        If a following pattern match is to be found, any position within a
                        contracting sequence except the first will fail. Vice versa if a
                        preceding pattern match is to be found, an invalid starting point
                        would be any character within a contracting sequence except the last.
                    </description>
                </item>
            </list>
            <para/>
            A <see cref="T:ICU4N.Text.BreakIterator"/> can be used if only matches at logical breaks are desired.
            Using a <see cref="T:ICU4N.Text.BreakIterator"/> will only give you results that exactly matches the
            boundaries given by the <see cref="T:ICU4N.Text.BreakIterator"/>. For instance the pattern "e" will
            not be found in the string "\u00e9" if a character break iterator is used.
            <para/>
            Options are provided to handle overlapping matches.
            E.g. In English, overlapping matches produces the result 0 and 2
            for the pattern "abab" in the text "ababab", where mutually
            exclusive matches only produces the result of 0.
            <para/>
            Options are also provided to implement "asymmetric search" as described in
            <a href="http://www.unicode.org/reports/tr10/#Asymmetric_Search">
            UTS #10 Unicode Collation Algorithm</a>, specifically the <see cref="T:ICU4N.Text.ElementComparisonType"/>
            values.
            <para/>
            Though collator attributes will be taken into consideration while
            performing matches, there are no APIs here for setting and getting the
            attributes. These attributes can be set by getting the collator
            from <see cref="P:ICU4N.Text.StringSearch.Collator"/> and using the APIs in <see cref="T:ICU4N.Text.RuleBasedCollator"/>.
            Lastly to update <see cref="T:ICU4N.Text.StringSearch"/> to the new collator attributes,
            <see cref="M:ICU4N.Text.StringSearch.Reset"/> has to be called.
            <para/>
            Restriction: <br/>
            Currently there are no composite characters that consists of a
            character with combining class &gt; 0 before a character with combining
            class == 0. However, if such a character exists in the future,
            <see cref="T:ICU4N.Text.StringSearch"/> does not guarantee the results for option 1.
            <para/>
            Consult the <see cref="T:ICU4N.Text.SearchIterator"/> documentation for information on
            and examples of how to use instances of this class to implement text
            searching.
            <para/>
            Note, <see cref="T:ICU4N.Text.StringSearch"/> is not inheritable.
            </summary>
            <seealso cref="T:ICU4N.Text.SearchIterator"/>
            <seealso cref="T:ICU4N.Text.RuleBasedCollator"/>
            <author>Laura Werner, synwee</author>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.StringSearch.#ctor(System.String,ICU4N.Support.Text.CharacterIterator,ICU4N.Text.RuleBasedCollator,ICU4N.Text.BreakIterator)">
            <summary>
            Initializes the iterator to use the language-specific rules defined in
            the argument <paramref name="collator"/> to search for argument <paramref name="pattern"/> in the argument
            <paramref name="target"/> text. The argument <paramref name="breakiter"/> is used to define logical matches.
            <para/>
            See super class documentation for more details on the use of the target
            text and <see cref="T:ICU4N.Text.BreakIterator"/>.
            </summary>
            <param name="pattern">Text to look for.</param>
            <param name="target">Target text to search for <paramref name="pattern"/>.</param>
            <param name="collator"><see cref="T:ICU4N.Text.RuleBasedCollator"/> that defines the language rules.</param>
            <param name="breakiter">A <see cref="T:ICU4N.Text.BreakIterator"/> that is used to determine the
            boundaries of a logical match. This argument can be null.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when argument <paramref name="target"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown when argument <paramref name="target"/> is length of 0.</exception>
            <seealso cref="T:ICU4N.Text.BreakIterator"/>
            <seealso cref="T:ICU4N.Text.RuleBasedCollator"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.StringSearch.#ctor(System.String,ICU4N.Support.Text.CharacterIterator,ICU4N.Text.RuleBasedCollator)">
            <summary>
            Initializes the iterator to use the language-specific rules defined in
            the argument <paramref name="collator"/> to search for argument <paramref name="pattern"/> in the argument
            <paramref name="target"/> text. No <see cref="T:ICU4N.Text.BreakIterator"/>s are set to test for logical matches.
            </summary>
            <param name="pattern">Text to look for.</param>
            <param name="target">Target text to search for <paramref name="pattern"/>.</param>
            <param name="collator"><see cref="T:ICU4N.Text.RuleBasedCollator"/> that defines the language rules.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when argument <paramref name="target"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown when argument <paramref name="target"/> is length of 0.</exception>
            <seealso cref="T:ICU4N.Text.RuleBasedCollator"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.StringSearch.#ctor(System.String,ICU4N.Support.Text.CharacterIterator,System.Globalization.CultureInfo)">
            <summary>
            Initializes the iterator to use the language-specific rules and
            break iterator rules defined in the argument <paramref name="locale"/> to search for
            argument <paramref name="pattern"/> in the argument target text.
            </summary>
            <param name="pattern">Text to look for.</param>
            <param name="target">Target text to search for <paramref name="pattern"/>.</param>
            <param name="locale">Locale to use for language and break iterator rules.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when argument <paramref name="target"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown when argument <paramref name="target"/> is length of 0.</exception>
            <exception cref="T:System.InvalidCastException">Thrown if the collator for the specfied <paramref name="locale"/> is not a <see cref="T:ICU4N.Text.RuleBasedCollator"/>.</exception>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.StringSearch.#ctor(System.String,ICU4N.Support.Text.CharacterIterator,ICU4N.Globalization.UCultureInfo)">
            <summary>
            Initializes the iterator to use the language-specific rules and
            break iterator rules defined in the argument <paramref name="locale"/> to search for
            argument <paramref name="pattern"/> in the argument <paramref name="target"/> text.
            <para/>
            See super class documentation for more details on the use of the target
            text and <see cref="T:ICU4N.Text.BreakIterator"/>.
            </summary>
            <param name="pattern">Text to look for.</param>
            <param name="target">Target text to search for <paramref name="pattern"/>.</param>
            <param name="locale">Locale to use for language and break iterator rules.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when argument <paramref name="target"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown when argument <paramref name="target"/> is length of 0.</exception>
            <exception cref="T:System.InvalidCastException">Thrown if the collator for the specfied <paramref name="locale"/> is not a <see cref="T:ICU4N.Text.RuleBasedCollator"/>.</exception>
            <seealso cref="T:ICU4N.Text.BreakIterator"/>
            <seealso cref="T:ICU4N.Text.RuleBasedCollator"/>
            <seealso cref="T:ICU4N.Text.SearchIterator"/>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.StringSearch.#ctor(System.String,System.String)">
            <summary>
            Initializes the iterator to use the language-specific rules and
            break iterator rules defined in the default locale to search for
            argument pattern in the argument target text.
            </summary>
            <param name="pattern">Text to look for.</param>
            <param name="target">Target text to search for <paramref name="pattern"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when argument <paramref name="target"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown when argument <paramref name="target"/> is length of 0.</exception>
            <exception cref="T:System.InvalidCastException">Thrown if the collator for the default locale is not a <see cref="T:ICU4N.Text.RuleBasedCollator"/>.</exception>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.StringSearch.Collator">
            <summary>
            Gets the <see cref="T:ICU4N.Text.RuleBasedCollator"/> used for the language rules.
            <para/>
            Since <see cref="T:ICU4N.Text.StringSearch"/> depends on the returned <see cref="T:ICU4N.Text.RuleBasedCollator"/>, any
            changes to the <see cref="T:ICU4N.Text.RuleBasedCollator"/> result should follow with a call to
            either <see cref="M:ICU4N.Text.StringSearch.Reset"/> or <see cref="M:ICU4N.Text.StringSearch.SetCollator(ICU4N.Text.RuleBasedCollator)"/> to ensure the correct
            search behavior.
            </summary>
            <seealso cref="T:ICU4N.Text.RuleBasedCollator"/>
            <seealso cref="M:ICU4N.Text.StringSearch.SetCollator(ICU4N.Text.RuleBasedCollator)"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="M:ICU4N.Text.StringSearch.SetCollator(ICU4N.Text.RuleBasedCollator)">
            <summary>
            Sets the <see cref="T:ICU4N.Text.RuleBasedCollator"/> to be used for language-specific searching.
            <para/>
            The iterator's position will not be changed by this method.
            </summary>
            <param name="collator">Collator to use for this <see cref="T:ICU4N.Text.StringSearch"/>.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="collator"/> is null.</exception>
            <seealso cref="P:ICU4N.Text.StringSearch.Collator"/>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.StringSearch.Pattern">
            <summary>
            Gets or sets the pattern for which <see cref="T:ICU4N.Text.StringSearch"/> is searching for.
            The iterator's position will not be changed.
            </summary>
            <stable>ICU 2.0</stable>
        </member>
        <member name="P:ICU4N.Text.StringSearch.IsCanonical">
            <summary>
            Gets or sets whether canonical matches (option 1, as described in the
            <see cref="T:ICU4N.Text.StringSearch"/> documentation) is set.
            <para/>
            The default setting for this property is <c>false</c>.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.StringSearch.SetTarget(ICU4N.Support.Text.CharacterIterator)">
            <summary>
            Set the target text to be searched. Text iteration will then begin at 
            the start of the text string. This method is useful if you want to 
            reuse an iterator to search within a different body of text.
            </summary>
            <param name="text">New text iterator to look for match.</param>
            <exception cref="T:System.ArgumentException">Thrown when text is null or has 0 length.</exception>
            <see cref="P:ICU4N.Text.SearchIterator.Target"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="P:ICU4N.Text.StringSearch.Index">
            <summary>
            Gets the current index in the text being searched.
            If the iteration has gone past the end of the text
            (or past the beginning for a backwards search), <see cref="F:ICU4N.Text.SearchIterator.Done"/>
            is returned.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.StringSearch.SetIndex(System.Int32)">
            <summary>
            Sets the position in the target text at which the next search will start.
            This method clears any previous match.
            </summary>
            <param name="position">Position from which to start the next search.</param>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if argument position is out of the target text range.</exception>
            <see cref="P:ICU4N.Text.StringSearch.Index"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.StringSearch.Reset">
            <summary>
            Resets the iteration.
            Search will begin at the start of the text string if a forward
            iteration is initiated before a backwards iteration. Otherwise if a
            backwards iteration is initiated before a forwards iteration, the
            search will begin at the end of the text string.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.StringSearch.HandleNext(System.Int32)">
            <summary>
            Abstract method which subclasses override to provide the mechanism
            for finding the next match in the target text. This allows different
            subclasses to provide different search algorithms.
            <para/>
            If a match is found, the implementation should return the index at
            which the match starts and should set
            <see cref="P:ICU4N.Text.SearchIterator.MatchLength"/> with the number of characters 
            in the target text that make up the match. If no match is found, the 
            method should return <see cref="F:ICU4N.Text.SearchIterator.Done"/>.
            </summary>
            <param name="position">The index in the target text at which the search 
            should start.</param>
            <returns>Index at which the match starts, else if match is not found
            <see cref="F:ICU4N.Text.SearchIterator.Done"/> is returned.</returns>
            <seealso cref="P:ICU4N.Text.SearchIterator.MatchLength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.StringSearch.HandlePrevious(System.Int32)">
            <summary>
            Abstract method which subclasses override to provide the mechanism for
            finding the previous match in the target text. This allows different
            subclasses to provide different search algorithms.
            <para/>
            If a match is found, the implementation should return the index at
            which the match starts and should set 
            <see cref="P:ICU4N.Text.SearchIterator.MatchLength"/> with the number of characters 
            in the target text that make up the match. If no match is found, the 
            method should return <see cref="F:ICU4N.Text.SearchIterator.Done"/>.
            </summary>
            <param name="position">The index in the target text at which the search
            should start.</param>
            <returns>Index at which the match starts, else if match is not found 
            <see cref="F:ICU4N.Text.SearchIterator.Done"/> is returned.</returns>
            <seealso cref="P:ICU4N.Text.SearchIterator.MatchLength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.StringSearch.GetMask(ICU4N.Text.CollationStrength)">
            <summary>
            Getting the mask for collation strength
            </summary>
            <param name="strength">Collation strength.</param>
            <returns>Collation element mask.</returns>
        </member>
        <member name="M:ICU4N.Text.StringSearch.GetCE(System.Int32)">
            <summary>
            Getting the modified collation elements taking into account the collation
            attributes.
            </summary>
            <param name="sourcece"></param>
            <returns>The modified collation element.</returns>
        </member>
        <member name="M:ICU4N.Text.StringSearch.AddToInt32Array(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Direct port of ICU4C static int32_t * addTouint32_tArray(...) in usearch.cpp
            (except not taking destination buffer size and status param).
            This is used for appending a PCE to Pattern.PCE_ buffer. We probably should
            implement this in <see cref="T:ICU4N.Text.StringSearch.UPattern"/> class.
            </summary>
            <param name="destination">Target array.</param>
            <param name="offset">Destination offset to add <paramref name="value"/>.</param>
            <param name="value">Value to be added.</param>
            <param name="increments">Incremental size expected.</param>
            <returns>New destination array, <paramref name="destination"/> if there was no new allocation.</returns>
        </member>
        <member name="M:ICU4N.Text.StringSearch.AddToInt64Array(System.Int64[],System.Int32,System.Int32,System.Int64,System.Int32)">
            <summary>
            Direct port of ICU4C static int64_t * addTouint64_tArray(...) in usearch.cpp.
            This is used for appending a PCE to Pattern.PCE_ buffer. We probably should
            implement this in <see cref="T:ICU4N.Text.StringSearch.UPattern"/> class.
            </summary>
            <param name="destination">Target array.</param>
            <param name="offset">Destination offset to add <paramref name="value"/>.</param>
            <param name="destinationlength">Target array size.</param>
            <param name="value">Value to be added.</param>
            <param name="increments">Incremental size expected.</param>
            <returns>New destination array, <paramref name="destination"/> if there was no new allocation.</returns>
        </member>
        <member name="M:ICU4N.Text.StringSearch.InitializePatternCETable">
            <summary>
            Initializing the ce table for a pattern.
            Stores non-ignorable collation keys.
            Table size will be estimated by the size of the pattern text. Table
            expansion will be perform as we go along. Adding 1 to ensure that the table
            size definitely increases.
            </summary>
            <returns>Total number of expansions.</returns>
        </member>
        <member name="M:ICU4N.Text.StringSearch.InitializePatternPCETable">
            <summary>
            Initializing the pce table for a pattern.
            Stores non-ignorable collation keys.
            Table size will be estimated by the size of the pattern text. Table
            expansion will be perform as we go along. Adding 1 to ensure that the table
            size definitely increases.
            </summary>
            <returns>Total number of expansions.</returns>
        </member>
        <member name="M:ICU4N.Text.StringSearch.SetMatchNotFound">
            <internal/>
        </member>
        <member name="M:ICU4N.Text.StringSearch.IsOutOfBounds(System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks if the offset runs out of the text string range.
            </summary>
            <param name="textstart">Offset of the first character in the range.</param>
            <param name="textlimit">Limit offset of the text string range.</param>
            <param name="offset">Offset to test.</param>
            <returns><c>true</c> if offset is out of bounds, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:ICU4N.Text.StringSearch.CheckIdentical(System.Int32,System.Int32)">
            <summary>
            Checks for identical match.
            </summary>
            <param name="start">Start offset of possible match.</param>
            <param name="end">End offset of possible match.</param>
            <returns><c>true</c> if identical match is found.</returns>
        </member>
        <member name="M:ICU4N.Text.StringSearch.NextBoundaryAfter(System.Int32)">
            <summary>
            Find the next break boundary after <paramref name="startIndex"/>. If the UStringSearch object
            has an external break iterator, use that. Otherwise use the internal character
            break iterator.
            </summary>
        </member>
        <member name="M:ICU4N.Text.StringSearch.IsBreakBoundary(System.Int32)">
            <summary>
            Returns <c>true</c> if <paramref name="index"/> is on a break boundary. If the UStringSearch
            has an external break iterator, test using that, otherwise test
            using the internal character break iterator.
            </summary>
        </member>
        <member name="T:ICU4N.Text.StringSearch.Match">
            <summary>
            An object used for receiving matched index in <see cref="M:ICU4N.Text.StringSearch.Search(System.Int32,ICU4N.Text.StringSearch.Match)"/> and
            <see cref="M:ICU4N.Text.StringSearch.SearchBackwards(System.Int32,ICU4N.Text.StringSearch.Match)"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Text.StringSearch.GetString(ICU4N.Support.Text.CharacterIterator,System.Int32,System.Int32)">
            <summary>
            Gets a substring out of a <see cref="T:ICU4N.Support.Text.CharacterIterator"/>.
            <para/>
            C# porting note: Not available in ICU4C
            </summary>
            <param name="text"><see cref="T:ICU4N.Support.Text.CharacterIterator"/>.</param>
            <param name="start">Start offset.</param>
            <param name="length">Length of substring.</param>
            <returns>Substring from <paramref name="text"/> starting at <paramref name="start"/> and <paramref name="length"/>.</returns>
        </member>
        <member name="T:ICU4N.Text.StringSearch.UPattern">
            <summary>
            C# port of ICU4C struct UPattern (usrchimp.h)
            </summary>
        </member>
        <member name="P:ICU4N.Text.StringSearch.UPattern.Text">
            Pattern string 
        </member>
        <member name="T:ICU4N.Text.StringSearch.CollationPCE">
            <summary>
            C# port of ICU4C UCollationPCE (usrchimp.h)
            </summary>
        </member>
        <member name="M:ICU4N.Text.StringSearch.CollationPCE.NextProcessed(ICU4N.Text.StringSearch.CollationPCE.Range)">
            <summary>
            Get the processed ordering priority of the next collation element in the text.
            A single character may contain more than one collation element.
            <para/>
            Note: This is equivalent to
            UCollationPCE::nextProcessed(int32_t *ixLow, int32_t *ixHigh, UErrorCode *status);
            </summary>
            <param name="range">Range receiving the iterator index before/after fetching the CE.</param>
            <returns>The next collation elements ordering, otherwise returns <see cref="F:ICU4N.Text.StringSearch.CollationPCE.PROCESSED_NULLORDER"/>
            if an error has occurred or if the end of string has been reached.</returns>
        </member>
        <member name="M:ICU4N.Text.StringSearch.CollationPCE.PreviousProcessed(ICU4N.Text.StringSearch.CollationPCE.Range)">
            <summary>
            Get the processed ordering priority of the previous collation element in the text.
            A single character may contain more than one collation element.
            <para/>
            Note: This is equivalent to
            UCollationPCE::previousProcessed(int32_t *ixLow, int32_t *ixHigh, UErrorCode *status);
            </summary>
            <param name="range">Range receiving the iterator index before/after fetching the CE.</param>
            <returns>The previous collation elements ordering, otherwise returns
            <see cref="F:ICU4N.Text.StringSearch.CollationPCE.PROCESSED_NULLORDER"/> if an error has occurred or if the start of
            string has been reached.</returns>
        </member>
        <member name="T:ICU4N.Text.StringSearch.CollationPCE.PCEI">
            <summary>Processed collation element buffer stuff ported from ICU4C ucoleitr.cpp</summary>
        </member>
        <member name="T:ICU4N.Text.StringSearch.CollationPCE.RCEI">
            <summary>Raw collation element buffer stuff ported from ICU4C ucoleitr.cpp</summary>
        </member>
        <member name="T:ICU4N.Text.StringSearch.CEI">
            <summary>
            C# port of ICU4C CEI (usearch.cpp)
            <para/>
            CEI  Collation Element + source text index.
                 These structs are kept in the circular buffer.
            </summary>
        </member>
        <member name="T:ICU4N.Text.StringSearch.CEBuffer">
            <summary>
            CEBuffer A circular buffer of CEs from the text being searched
            </summary>
        </member>
    </members>
</doc>
